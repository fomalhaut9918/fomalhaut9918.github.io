---
wiki: game
title: Some simple games
cover: https://cdn.jsdelivr.net/gh/fomalhaut9918/blog-img@main/back.png
---

# 欢迎光临！ {% emoji 爱你 %}

下面是一个贪吃蛇小游戏。

<div id="gameContainer" style="position: relative; max-width: 600px; width: 90%; margin: 40px auto; overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.2); background: #fff;">
  <canvas id="snakeCanvas" width="600" height="600" style="display: block; width: 100%; height: auto; border: none; background: linear-gradient(135deg, #ffffff, #ecf0f1); border-radius: 12px;"></canvas>
</div>

<div style="text-align: center; margin-top: 20px;">
  <div id="gameMessage" style="font-size: 22px; font-weight: 500;">点击开始游戏</div>
  <button id="startBtn" style="padding: 12px 24px; margin-top: 12px; font-size: 16px; border: none; border-radius: 6px; background-color: #3333cc; color: #fff; cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: background-color 0.3s;">开始</button>
</div>

<style>
  /* 保持页面背景为空白 */
  body {
    background: #fff;
    color: #000;
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    text-align: center;
  }
  /* 禁止页面在游戏区域滚动 */
  #gameContainer {
    touch-action: none;
  }
  /* 按钮悬停效果 */
  #startBtn:hover {
    background-color: #222299;
  }
</style>

<script>
(function() {
    const canvas = document.getElementById('snakeCanvas');
    const ctx = canvas.getContext('2d');
    // 每个网格单元
    const box = 20;
    const canvasSize = 600;
    let snake, prevSnake, food, direction, score, gameOver;

    // 固定时间步长（秒）
    const fixedDelta = 0.1;
    let accumulator = 0;
    let lastTime = performance.now();

    let running = false;
    const gameMessage = document.getElementById('gameMessage');
    const startBtn = document.getElementById('startBtn');

    // 用于手势检测的变量
    let touchStartX = 0, touchStartY = 0;

    // 绘制圆角矩形的辅助函数
    function drawRoundedRect(x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    // 初始化游戏状态，并滚动聚焦至游戏区域
    function initGame() {
        // 初始蛇的起始位置（存储上一次状态以用于插值）
        snake = [
            { x: Math.floor(canvasSize / (2 * box)) * box, y: Math.floor(canvasSize / (2 * box)) * box }
        ];
        // 克隆数组用于插值（初始时两者相等）
        prevSnake = JSON.parse(JSON.stringify(snake));
        food = generateFood();
        direction = 'right';
        score = 0;
        gameOver = false;
        gameMessage.innerText = "";
        startBtn.style.display = 'none';
        document.getElementById('gameContainer').scrollIntoView({ behavior: 'smooth', block: 'center' });
        lastTime = performance.now();
        accumulator = 0;
    }

    // 生成不会撞到蛇的食物
    function generateFood() {
        let foodItem;
        do {
            foodItem = {
                x: Math.floor(Math.random() * (canvasSize / box)) * box,
                y: Math.floor(Math.random() * (canvasSize / box)) * box
            };
        } while (collision(foodItem.x, foodItem.y, snake));
        return foodItem;
    }

    // 碰撞检测：判断 (x, y) 是否在数组中存在
    function collision(x, y, array) {
        for (let i = 0; i < array.length; i++) {
            if (x === array[i].x && y === array[i].y) return true;
        }
        return false;
    }

    // 更新游戏逻辑：在更新前保存当前状态到 prevSnake 用于插值动画
    function updateLogic() {
        prevSnake = JSON.parse(JSON.stringify(snake));
        let head = { x: snake[0].x, y: snake[0].y };
        switch(direction) {
            case 'left':  head.x -= box; break;
            case 'right': head.x += box; break;
            case 'up':    head.y -= box; break;
            case 'down':  head.y += box; break;
        }
        // 撞墙或撞自身则判定游戏结束
        if (head.x < 0 || head.y < 0 || head.x >= canvasSize || head.y >= canvasSize || collision(head.x, head.y, snake)) {
            gameOver = true;
            return;
        }
        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
            score++;
            food = generateFood();
        } else {
            snake.pop();
        }
    }

    // 利用持续更新后的插值进行平滑渲染
    function draw() {
        ctx.clearRect(0, 0, canvasSize, canvasSize);
        // 绘制画布背景渐变
        let bgGradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize);
        bgGradient.addColorStop(0, '#ffffff');
        bgGradient.addColorStop(1, '#ecf0f1');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, canvasSize, canvasSize);

        // 设置阴影效果，用于食物和蛇的绘制
        ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
        ctx.shadowBlur = 6;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        // 绘制食物的圆角方块
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#fff';
        ctx.fillStyle = 'red';
        drawRoundedRect(food.x + 2, food.y + 2, box - 4, box - 4, 4);

        // 绘制蛇体，采用插值平滑动画，且用渐变过渡颜色
        for (let i = 0; i < snake.length; i++) {
            // 若上一帧数据存在，则计算插值坐标；否则直接使用当前数据
            let prevPos = (prevSnake && prevSnake[i]) ? prevSnake[i] : snake[i];
            let t = accumulator / fixedDelta;
            let interpX = prevPos.x + t * (snake[i].x - prevPos.x);
            let interpY = prevPos.y + t * (snake[i].y - prevPos.y);
            // 蛇头和身躯颜色不同，蛇头采用深色
            if (i === 0) {
                ctx.fillStyle = '#2c3e50';
            } else {
                // 计算渐变：靠近头部颜色更深，靠近尾部颜色较浅
                let ratio = i / snake.length;
                let r = Math.floor(44 + ratio * (105 - 44));  // interpolate between 44 and 105
                let g = Math.floor(62 + ratio * (152 - 62));
                let b = Math.floor(80 + ratio * (219 - 80));
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            }
            ctx.strokeStyle = 'white';
            // 绘制圆角蛇体块
            drawRoundedRect(interpX + 2, interpY + 2, box - 4, box - 4, 4);
        }

        // 绘制分数，无阴影
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.textAlign = 'left';
        ctx.fillText("Score: " + score, 5, canvasSize - 5);
    }

    // 主游戏循环：采用 requestAnimationFrame 与固定步长更新，并用插值实现平滑动画
    function gameLoop(timestamp) {
        if (!running) return;
        let dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        accumulator += dt;
        while (accumulator >= fixedDelta) {
            if (!gameOver) {
                updateLogic();
            }
            accumulator -= fixedDelta;
        }
        draw();
        if (gameOver) {
            showGameOver();
            running = false;
            return;
        }
        requestAnimationFrame(gameLoop);
    }

    function showGameOver() {
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(0, 0, canvasSize, canvasSize);
        ctx.fillStyle = "white";
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", canvasSize / 2, canvasSize / 2 - 20);
        gameMessage.innerText = "游戏结束，最终得分：" + score;
        startBtn.innerText = "重新开始";
        startBtn.style.display = "inline-block";
    }

    // 桌面端键盘操作
    document.addEventListener('keydown', function(event) {
        if (!gameOver) {
            switch (event.key.toLowerCase()) {
                case 'w':
                    if (direction !== 'down') direction = 'up';
                    break;
                case 'a':
                    if (direction !== 'right') direction = 'left';
                    break;
                case 's':
                    if (direction !== 'up') direction = 'down';
                    break;
                case 'd':
                    if (direction !== 'left') direction = 'right';
                    break;
            }
        }
    });

    // 移动端手势：通过 touchstart、touchmove 和 touchend 控制方向
    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        const touch = e.changedTouches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
    }, {passive: false});

    canvas.addEventListener('touchmove', function(e) {
        e.preventDefault();
    }, {passive: false});

    canvas.addEventListener('touchend', function(e) {
        const touch = e.changedTouches[0];
        const deltaX = touch.clientX - touchStartX;
        const deltaY = touch.clientY - touchStartY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 20 && direction !== 'left') {
                direction = 'right';
            } else if (deltaX < -20 && direction !== 'right') {
                direction = 'left';
            }
        } else {
            if (deltaY > 20 && direction !== 'up') {
                direction = 'down';
            } else if (deltaY < -20 && direction !== 'down') {
                direction = 'up';
            }
        }
    }, {passive: false});

    // 开始或重新开始游戏按钮事件
    startBtn.addEventListener('click', function() {
        initGame();
        running = true;
        requestAnimationFrame(gameLoop);
    });

    gameMessage.innerText = "点击开始游戏";
})();
</script>

<p style="text-align: center;">使用键盘（WASD）或滑动手势操控方向，挑战你的反应速度！</p>