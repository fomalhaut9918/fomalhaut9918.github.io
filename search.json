[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏 (高级AI版)","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。支持两步确认落子。电脑最后一次落子处以红色圆环标出。 /* 页面基础样式 */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} /* 加载指示器 */ .thinking-indicator{display:inline-block;margin-left:10px;width:24px;height:24px;vertical-align:middle;border:3px solid rgba(0,0,0,0.1);border-radius:50%;border-top-color:#3498db;animation:spin 1s linear infinite;display:none} @keyframes spin{to{transform:rotate(360deg)}} 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。 (function() { // --- 配置 --- const boardSize = 15; // 棋盘大小 15x15 const internalCanvasSize = 640; // 画布内部大小 const margin = 30; // 边距 const WIN_CONDITION = 5; // 获胜条件：连续5子 const MAX_SEARCH_DEPTH = 4; // 最大搜索深度 const THREAT_SEARCH_DEPTH = 6; // 威胁空间搜索深度 // --- DOM 元素 --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const thinkingIndicator = document.getElementById('thinkingIndicator'); // --- 游戏状态 --- let board = []; // 棋盘状态 let turn = \"\"; // 当前回合：player 或 computer let gameOver = true; // 游戏是否结束 let playerIsBlack = true; // 玩家是否执黑 let playerPiece = 1; // 玩家棋子：1=黑, 2=白 let aiPiece = 2; // AI棋子：2=白, 1=黑 let isAiComputing = false; // AI是否正在计算 let pendingMove = null; // 待确认的走法 let lastComputerMove = null; // 电脑最后一步走法 let transpositionTable = new Map(); // 置换表，用于存储已搜索过的局面 let historyTable = []; // 历史表，用于存储优秀的走法 // --- 计算棋盘单元格大小 --- const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // --- 棋型评分系统 --- // 定义各种棋型的评分 const PATTERN_SCORES = { // 连五 FIVE: 1000000, // 活四（两端都是空位） OPEN_FOUR: 100000, // 冲四（只有一端是空位） FOUR: 10000, // 双活三 DOUBLE_OPEN_THREE: 50000, // 活三（两端都是空位） OPEN_THREE: 5000, // 眠三（只有一端是空位） THREE: 1000, // 活二（两端都是空位） OPEN_TWO: 500, // 眠二（只有一端是空位） TWO: 100, // 活一（两端都是空位） OPEN_ONE: 50, // 眠一（只有一端是空位） ONE: 10, // 权重系数 ATTACK_FACTOR: 1.0, // 进攻系数 DEFENSE_FACTOR: 1.1 // 防守系数（略高于进攻，鼓励防守） }; // --- 棋盘位置权重 --- // 越接近中心的位置，权重越高 const POSITION_VALUES = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0], [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 6, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 6, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0], [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0], [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]; // --- 开局库 --- // 包含一些经典的五子棋开局 const OPENING_BOOK = { // 天元开局 'center': [ {i: 7, j: 7} // 天元点 ], // 黑方天元开局后，白方的应对 '7-7': [ {i: 6, j: 6}, // 左上 {i: 6, j: 8}, // 左下 {i: 8, j: 6}, // 右上 {i: 8, j: 8} // 右下 ], // 花月开局 'huayue': [ {i: 7, j: 7}, // 天元 {i: 7, j: 6}, // 花月位 {i: 8, j: 6} // 应手 ], // 星开局 'star': [ {i: 7, j: 7}, // 天元 {i: 3, j: 3}, // 星位 {i: 11, j: 11} // 应手 ] }; // --- 初始化历史表 --- function initHistoryTable() { historyTable = []; for (let i = 0; i < boardSize; i++) { historyTable[i] = []; for (let j = 0; j < boardSize; j++) { historyTable[i][j] = 0; } } } // --- 初始化棋盘 --- function initBoard() { board = []; for (let i = 0; i < boardSize; i++) { board[i] = []; for (let j = 0; j < boardSize; j++) { board[i][j] = 0; } } lastComputerMove = null; pendingMove = null; transpositionTable.clear(); initHistoryTable(); } // --- 重新开始游戏 --- function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"请选择是否先手：\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; thinkingIndicator.style.display = \"none\"; initBoard(); drawBoard(); } // --- 设置游戏 --- function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"游戏开始，请您落子 (黑棋)\" : \"游戏开始，电脑先手 (黑棋)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; // 如果AI先手，走天元 if (turn === \"computer\") { const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { makeMove(center, center, aiPiece); lastComputerMove = {i: center, j: center}; drawBoard(); turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } else { setTimeout(computerMove, 200); } } } // --- 结束游戏 --- function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"恭喜你，你赢了！🎉\"; else if (winnerPiece === aiPiece) winnerText = \"很遗憾，你输了。🤖\"; else winnerText = \"平局！\"; gameMessage.innerText = \"游戏结束 - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; thinkingIndicator.style.display = \"none\"; drawBoard(); } // --- 计算当前棋盘状态的哈希值 (用于置换表) --- function hashBoard() { let hash = 0; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) { hash = hash * 3 + board[i][j]; } } } return hash; } // --- 高级棋型识别 --- // 分析棋型的核心函数 function analyzeLine(line, piece) { const opponent = piece === 1 ? 2 : 1; // 连五 if (line.includes(piece.toString().repeat(5))) { return PATTERN_SCORES.FIVE; } // 活四: 0XXXX0 (一步就能连五) if (line.includes(`0${piece.toString().repeat(4)}0`)) { return PATTERN_SCORES.OPEN_FOUR; } // 冲四: XXXX0 或 0XXXX (单向可以连五) if (line.includes(`${piece.toString().repeat(4)}0`) || line.includes(`0${piece.toString().repeat(4)}`)) { return PATTERN_SCORES.FOUR; } // 活三: 0XXX0 (可以形成活四) if (line.includes(`0${piece.toString().repeat(3)}0`)) { return PATTERN_SCORES.OPEN_THREE; } // 眠三: XXX0 或 0XXX if (line.includes(`${piece.toString().repeat(3)}0`) || line.includes(`0${piece.toString().repeat(3)}`)) { return PATTERN_SCORES.THREE; } // 活二: 0XX0 (可以形成活三) if (line.includes(`0${piece.toString().repeat(2)}0`)) { return PATTERN_SCORES.OPEN_TWO; } // 眠二: XX0 或 0XX if (line.includes(`${piece.toString().repeat(2)}0`) || line.includes(`0${piece.toString().repeat(2)}`)) { return PATTERN_SCORES.TWO; } // 活一: 0X0 (可以形成活二) if (line.includes(`0${piece.toString()}0`)) { return PATTERN_SCORES.OPEN_ONE; } // 眠一: X0 或 0X if (line.includes(`${piece.toString()}0`) || line.includes(`0${piece.toString()}`)) { return PATTERN_SCORES.ONE; } return 0; } // --- 新的五元组评估方法 --- // 评估棋盘上特定位置的五元组 function evaluateFiveGroup(row, col, piece) { // 四个方向: 水平、垂直、主对角线、副对角线 const directions = [ {dr: 1, dc: 0}, // 水平 {dr: 0, dc: 1}, // 垂直 {dr: 1, dc: 1}, // 主对角线 {dr: 1, dc: -1} // 副对角线 ]; let totalScore = 0; // 检查每个方向上的五元组 for (const {dr, dc} of directions) { // 保存当前方向上的棋子序列 let line = ''; // 向前扩展4步，向后扩展4步，总共检查9个位置 for (let step = -4; step = 0 && r < boardSize && c >= 0 && c < boardSize) { line += board[r][c]; } else { line += 'E'; // 边界外用E表示 } } // 将棋盘状态编码为字符串，便于分析 line = line.replace(/0/g, '0').replace(/1/g, '1').replace(/2/g, '2').replace(/E/g, 'E'); // 提取五元组 for (let i = 0; i 0 && opponentCount > 0) continue; // 自己的棋型评分 if (selfCount > 0 && opponentCount === 0) { if (selfCount === 5) totalScore += PATTERN_SCORES.FIVE; else if (selfCount === 4 && emptyCount === 1) { if (fiveGroup.includes(`0${piece.toString().repeat(4)}`) || fiveGroup.includes(`${piece.toString().repeat(4)}0`)) { totalScore += PATTERN_SCORES.FOUR; } else { totalScore += PATTERN_SCORES.OPEN_FOUR; } } else if (selfCount === 3 && emptyCount === 2) { if (fiveGroup === `0${piece.toString().repeat(3)}0`) { totalScore += PATTERN_SCORES.OPEN_THREE; } else { totalScore += PATTERN_SCORES.THREE; } } else if (selfCount === 2 && emptyCount === 3) { if (fiveGroup.includes(`0${piece.toString().repeat(2)}0`)) { totalScore += PATTERN_SCORES.OPEN_TWO; } else { totalScore += PATTERN_SCORES.TWO; } } else if (selfCount === 1 && emptyCount === 4) { if (fiveGroup.includes(`0${piece.toString()}0`)) { totalScore += PATTERN_SCORES.OPEN_ONE; } else { totalScore += PATTERN_SCORES.ONE; } } } // 对手的棋型评分 (负分，表示潜在威胁) if (opponentCount > 0 && selfCount === 0) { if (opponentCount === 5) totalScore -= PATTERN_SCORES.FIVE * 1.2; else if (opponentCount === 4 && emptyCount === 1) { if (fiveGroup.includes(`0${(3-piece).toString().repeat(4)}`) || fiveGroup.includes(`${(3-piece).toString().repeat(4)}0`)) { totalScore -= PATTERN_SCORES.FOUR * 1.2; } else { totalScore -= PATTERN_SCORES.OPEN_FOUR * 1.2; } } else if (opponentCount === 3 && emptyCount === 2) { if (fiveGroup === `0${(3-piece).toString().repeat(3)}0`) { totalScore -= PATTERN_SCORES.OPEN_THREE * 1.2; } else { totalScore -= PATTERN_SCORES.THREE * 1.2; } } else if (opponentCount === 2 && emptyCount === 3) { if (fiveGroup.includes(`0${(3-piece).toString().repeat(2)}0`)) { totalScore -= PATTERN_SCORES.OPEN_TWO * 1.1; } else { totalScore -= PATTERN_SCORES.TWO * 1.1; } } } } } } return totalScore; } // --- 生成有效的候选落子点 --- function generateCandidates() { const candidates = []; const center = Math.floor(boardSize / 2); const radius = 1; // 搜索半径 // 检查是否是开局 let stoneCount = 0; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) { stoneCount++; } } } // 第一步：走天元 if (stoneCount === 0) { return [{i: center, j: center, score: 100000}]; } // 检查能够直接获胜的点 for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) continue; // 检查AI是否能获胜 board[i][j] = aiPiece; if (checkWin(i, j, aiPiece)) { board[i][j] = 0; return [{i: i, j: j, score: PATTERN_SCORES.FIVE}]; } board[i][j] = 0; // 检查是否需要阻止玩家获胜 board[i][j] = playerPiece; if (checkWin(i, j, playerPiece)) { board[i][j] = 0; return [{i: i, j: j, score: PATTERN_SCORES.FIVE * 0.9}]; } board[i][j] = 0; } } // 创建棋盘热力图 const heatMap = createHeatMap(); // 根据热力图生成候选点 for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0 || heatMap[i][j] === 0) continue; // 评估此位置的价值 const positionValue = evaluatePosition(i, j); const historyScore = historyTable[i][j]; // 历史表分数 candidates.push({ i: i, j: j, score: positionValue + heatMap[i][j] + historyScore * 0.5 }); } } // 如果没有找到候选点，扩大搜索范围 if (candidates.length === 0) { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) { // 到中心的距离 const distToCenter = Math.abs(i - center) + Math.abs(j - center); candidates.push({ i: i, j: j, score: 100 - distToCenter }); } } } } // 按分数排序 candidates.sort((a, b) => b.score - a.score); // 返回前15个候选点，采用启发式缩小搜索空间 return candidates.slice(0, 15); } // --- 创建棋盘热力图 --- function createHeatMap() { // 初始化热力图 const heatMap = Array(boardSize).fill().map(() => Array(boardSize).fill(0)); // 对于棋盘上的每一个已有棋子，增加其周围位置的热度 for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) continue; // 在该棋子周围3x3区域增加热度 for (let di = -2; di"}]