[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。另外，游戏支持两步确认落子：第一次点击显示预落子效果，第二次点击确认落子。电脑最后一次落子处以红色圆环标出，帮助直观查看电脑决策。 /* 页面基础样式 */ body { background: #f8f8f8; /* Slightly softer background */ color: #333; /* Standard text color */ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font stack */ margin: 0; padding: 0; text-align: center; line-height: 1.6; } /* Prevent scrolling on the game area on touch devices */ #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } /* Dark Blue */ #secondBtn { background-color: #8e44ad; } /* Purple */ #restartBtn { background-color: #27ae60; } /* Green */ /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; /* Responsive width */ margin: 30px auto; /* Adjusted margin */ overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* Softer shadow */ background: #fdf6e3; /* Board background */ aspect-ratio: 1 / 1; /* Maintain square aspect ratio */ } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; /* Fill container */ border: none; background: #fdf6e3; /* Same as container, or transparent */ border-radius: 12px; /* Match container */ } #gameMessage { font-size: 20px; /* Slightly smaller */ font-weight: 500; margin-top: 0; /* Removed default margin */ margin-bottom: 15px; /* Space before buttons */ color: #555; } /* Adding a class for the intro text below the H1 */ .info-text { font-size: 14px; color: #666; margin-top: 10px; /* Reduced top margin */ margin-bottom: 20px; /* Space before game container */ padding: 0 15px; /* Add padding on smaller screens */ } /* Style for H1 */ h1 { margin-top: 20px; /* Space above title */ margin-bottom: 10px; /* Space below title */ color: #333; } 欢迎来到五子棋游戏 内置AI使用极大极小搜索与α-β剪枝。选择先手执黑，后手执白。 单击棋盘预落子，再次单击确认。电脑最后落子以红色圆环标出。 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 (function() { // --- Configuration --- const boardSize = 15; // Standard 15x15 board const internalCanvasSize = 640; // High internal resolution const margin = 30; // Increased margin for better edge spacing // --- INCREASED DEPTH for stronger AI --- (Adjust based on performance) const MAX_DEPTH = 4; // Increased depth slightly const WIN_CONDITION = 5; // 5 in a row to win // --- DOM Elements --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const gameContainer = document.getElementById('gameContainer'); // Needed for aspect ratio // --- Game State --- let board = []; // 0: empty, 1: black, 2: white let turn = \"\"; // \"player\", \"computer\", or \"\" (before start) let gameOver = true; // Start in game over state until first/second chosen let playerIsBlack = true; // Player's color choice let playerPiece = 1; // Piece value for the player let aiPiece = 2; // Piece value for the AI let isAiComputing = false; // Flag to prevent clicks during AI turn let pendingMove = null; // {i, j} for two-step confirmation let lastComputerMove = null;// {i, j} to highlight AI's last move // Calculate cell size based on internal resolution and margin const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // --- Pattern Scores --- (Global or passed around) // Values can be tuned further based on testing const scores = { // AI Scores (Positive) FIVE: 100000000, // AI Win LIVE_FOUR: 1000000, // AI Live Four (Threat) DEAD_FOUR: 50000, // AI Dead Four LIVE_THREE: 50000, // AI Live Three (Increased value) DEAD_THREE: 1000, // AI Dead Three LIVE_TWO: 500, // AI Live Two DEAD_TWO: 10, // AI Dead Two LIVE_ONE: 5, // AI Live One DEAD_ONE: 1, // AI Dead One // Player Scores (Negative, higher absolute value means more urgent for AI to block) OPP_FIVE: -1000000000, // Player Win (Highest priority to block if somehow possible) OPP_LIVE_FOUR: -5000000,// Player Live Four (VERY URGENT) OPP_DEAD_FOUR: -100000, // Player Dead Four OPP_LIVE_THREE: -100000,// Player Live Three (URGENT) - Increased urgency OPP_DEAD_THREE: -5000, // Player Dead Three OPP_LIVE_TWO: -1000, // Player Live Two OPP_DEAD_TWO: -50, // Player Dead Two OPP_LIVE_ONE: -10, // Player Live One OPP_DEAD_ONE: -1 // Player Dead One }; // Priority levels for move ordering const PRIORITIES = { AI_WIN: 10, // AI can win in one move BLOCK_OPP_WIN: 9, // Block opponent win (must do) AI_LIVE_FOUR: 8, // Create AI live four BLOCK_OPP_LIVE_FOUR: 7, // Block opponent live four BLOCK_OPP_DEAD_FOUR_LIVE_THREE: 6, // Block opponent combo AI_LIVE_THREE: 5, // Create AI live three BLOCK_OPP_LIVE_THREE: 4,// Block opponent live three NORMAL: 1, // Regular move based on evaluation LOW: 0 // Low priority }; // =========================================== // Initialization and Game Control Functions (Unchanged) // =========================================== function initBoard() { /* ... unchanged ... */ } function setupGame(playerStarts) { /* ... unchanged ... */ } function restartGame() { /* ... unchanged ... */ } function endGame(winnerPiece) { /* ... unchanged ... */ } function checkDraw() { /* ... unchanged ... */ } // =========================================== // Drawing Functions (Unchanged) // =========================================== function drawBoard() { /* ... unchanged ... */ } function drawStone(i, j, type) { /* ... unchanged ... */ } function drawGhostStone(i, j, type) { /* ... unchanged ... */ } function highlightComputerMove(i, j) { /* ... unchanged ... */ } // =========================================== // Game Logic & Win Check (Unchanged checkWin) // =========================================== function checkWin(x, y, piece) { /* ... unchanged ... */ } // =========================================== // AI Logic (Minimax with Alpha-Beta) - FURTHER IMPROVED // =========================================== function cloneBoard(src) { // Correct deep copy return src.map(row => row.slice()); } // --- FURTHER IMPROVED Evaluation Function --- // Evaluates patterns more accurately by checking flanking positions function evaluateBoardState(boardState) { let totalScore = 0; const directions = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}]; // Evaluate all lines of 5, 6, 7 for patterns // A line of 6 allows checking open ends for a 5-in-a-row pattern etc. for (let len = 5; len 0 ? counts.ai : counts.player; const scoreSign = counts.ai > 0 ? 1 : -1; // 1 for AI, -1 for Player // --- Pattern Evaluation based on count and open ends --- // This is a simplified example; a full implementation would be more complex, // checking specific patterns like \"0XXXX0\", \"WXXXX0\", \"0XXX00\" etc. // Check 5-in-a-row (WIN Condition) if (pieceCount === 5 && len >= 5) { totalScore += scoreSign * scores.FIVE; continue; // No need to evaluate further if a win is found for this line type } // Check 4-in-a-row patterns if (pieceCount === 4) { // Check flanking spots for open ends (using len=6 primarily) let openEnds = 0; const prev_i = i - dx; const prev_j = j - dy; const next_i = i + len * dx; // Correct index for position after the line const next_j = j + len * dy; // Simplified check: Requires a line of 6 (0XXXX0) or 7 (0XXXX00, 00XXXX0) // More accurately, check the direct neighbors of the 4-group // Example check for LIVE FOUR (0XXXX0 pattern within len 6) if (len === 6 && line[0] === 0 && line[5] === 0) { totalScore += scoreSign * scores.LIVE_FOUR; } else if (len >= 5) { // Check for DEAD FOUR (WXXXX0 or 0XXXXW etc.) let isDead = false; // Example: Check within a line of 5 (WXXXX, XXXXW) if(len === 5 && (line[0] !== 0 && line[0] !== pieceType) || (line[4] !== 0 && line[4] !== pieceType) ) { isDead = true; } // Example: Check within a line of 6 (0XXXXW, WXXXX0) if(len === 6 && ((line[0] === 0 && line[5] !== 0 && line[5] !== pieceType) || (line[5] === 0 && line[0] !== 0 && line[0] !== pieceType)) ) { isDead = true; } if(isDead) { totalScore += scoreSign * scores.DEAD_FOUR; } else { // Could be a four within a longer empty stretch, potentially live if neighbors allow // For simplicity, if not clearly dead, treat as potential live four if one end is open in the 5-segment if(len===5 && (line[0] === 0 || line[4] === 0)) { totalScore += scoreSign * scores.LIVE_FOUR / 2; // Less certain than 0XXXX0 } else { totalScore += scoreSign * scores.DEAD_FOUR; // Default to dead if unclear } } } } // Check 3-in-a-row patterns (similar logic for Live/Dead based on flanking) if (pieceCount === 3) { // Example check for LIVE THREE (0XXX0 pattern within len 5) if(len === 5 && line[0] === 0 && line[4] === 0) { totalScore += scoreSign * scores.LIVE_THREE; } else if (len >= 4) { // Check DEAD THREE let isDead = false; // Example check within len 4 (WXXX, XXXW) if(len === 4 && ((line[0] !== 0 && line[0] !== pieceType) || (line[3] !== 0 && line[3] !== pieceType))) isDead = true; // Example check within len 5 (0XXXW, WXXX0) if(len === 5 && ((line[0] === 0 && line[4] !== 0 && line[4] !== pieceType) || (line[4] === 0 && line[0] !== 0 && line[0] !== pieceType))) isDead = true; if(isDead) { totalScore += scoreSign * scores.DEAD_THREE; } else { // Check for potential live three within len 4 (0XXX, XXX0) if(len===4 && (line[0] === 0 || line[3] === 0)){ totalScore += scoreSign * scores.LIVE_THREE / 2; // Less certain } else { totalScore += scoreSign * scores.DEAD_THREE; // Default to dead } } } } // Check 2-in-a-row patterns (similar logic) if (pieceCount === 2) { // Example Check for LIVE TWO (e.g., 0XX0 pattern within len 4) if(len === 4 && line[0] === 0 && line[3] === 0) { totalScore += scoreSign * scores.LIVE_TWO; } else if(len >= 3) { // Check DEAD TWO let isDead = false; if(len === 3 && ((line[0] !== 0 && line[0] !== pieceType) || (line[2] !== 0 && line[2] !== pieceType))) isDead = true; if(len === 4 && ((line[0] === 0 && line[3] !== 0 && line[3] !== pieceType) || (line[3] === 0 && line[0] !== 0 && line[0] !== pieceType))) isDead = true; if(isDead) { totalScore += scoreSign * scores.DEAD_TWO; } else { if(len===3 && (line[0] === 0 || line[2] === 0)){ totalScore += scoreSign * scores.LIVE_TWO / 2; } else { totalScore += scoreSign * scores.DEAD_TWO; } } } } // Add scores for single pieces if desired (LIVE/DEAD ONE) - less impactful usually } } } } // Add a small penalty for opponent having initiative (being the next to move) // if(turn === playerPiece) totalScore -= 10; else totalScore += 10; return totalScore; } // --- FURTHER IMPROVED Candidate Move Generation & Prioritization --- function getCandidateMoves(boardState, radius = 1) { let candidates = new Map(); // Use Map: key=`${i},${j}`, value={i, j, bonus, priority} let hasStones = false; const center = Math.floor(boardSize / 2); const opponentPiece = (aiPiece === 1) ? 2 : 1; // --- Phase 1: Find Urgent Moves (Wins and Must-Blocks) --- const urgentMoves = new Map(); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) { // Only consider empty spots // Check if AI can win here boardState[i][j] = aiPiece; if (checkWin(i, j, aiPiece)) { urgentMoves.set(`${i},${j}`, { i, j, priority: PRIORITIES.AI_WIN }); boardState[i][j] = 0; // Backtrack // If AI can win, this is the ONLY move that matters at this level // console.log(\"Found AI win move:\", i, j); // return [{ i, j, priority: PRIORITIES.AI_WIN, bonus: 0 }]; // Optimization: return immediately continue; // Check other potential win spots (though first is sufficient) } boardState[i][j] = 0; // Backtrack // Check if Player could win here (must block) boardState[i][j] = opponentPiece; if (checkWin(i, j, opponentPiece)) { if (!urgentMoves.has(`${i},${j}`)) { // Don't overwrite AI win priority urgentMoves.set(`${i},${j}`, { i, j, priority: PRIORITIES.BLOCK_OPP_WIN }); } // console.log(\"Found Must Block move:\", i, j); } boardState[i][j] = 0; // Backtrack } } } // If AI win moves exist, return only those (or the first one found) const aiWinMoves = Array.from(urgentMoves.values()).filter(m => m.priority === PRIORITIES.AI_WIN); if (aiWinMoves.length > 0) { return aiWinMoves.map(m => ({...m, bonus: 0})); // Return all win moves or just the first // return [{...aiWinMoves[0], bonus: 0}]; } // If opponent win block moves exist, add them to the main candidate list with high priority urgentMoves.forEach((move, key) => { if (move.priority === PRIORITIES.BLOCK_OPP_WIN) { candidates.set(key, { ...move, bonus: 0 }); } }); // --- Phase 2: Generate Moves Around Existing Stones (Radius Search) --- for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // Look around this stone for (let di = -radius; di { if (b.priority !== a.priority) { return b.priority - a.priority; // Higher priority first } // If priorities are equal, use heuristic score return maximizingPlayer ? b.heuristicScore - a.heuristicScore : a.heuristicScore - b.heuristicScore; }); // ------------------------------------------------------------ if (maximizingPlayer) { // AI's turn let maxEval = -Infinity; for (const move of candidates) { boardState[move.i][move.j] = aiPiece; let currentEval = minimax(boardState, depth - 1, alpha, beta, false); boardState[move.i][move.j] = 0; maxEval = Math.max(maxEval, currentEval); alpha = Math.max(alpha, currentEval); if (beta { const currentBoardState = cloneBoard(board); // Use a copy for AI calculation const startTime = performance.now(); // Track time const bestMove = getBestMove(currentBoardState, MAX_DEPTH); // Uses the improved AI logic const endTime = performance.now(); console.log(`AI calculation took: ${(endTime - startTime).toFixed(2)} ms`); // --- Critical Check: Ensure game hasn't ended or turn changed while AI was thinking --- if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI calculation aborted, game state changed.\"); return; } if (bestMove && board[bestMove.i][bestMove.j] === 0) { // Double-check spot is still empty // --- Make the AI Move --- board[bestMove.i][bestMove.j] = aiPiece; lastComputerMove = { i: bestMove.i, j: bestMove.j }; // Record for highlighting drawBoard(); // Draw the AI's move immediately // --- Check Game Status After AI Move --- if (checkWin(bestMove.i, bestMove.j, aiPiece)) { endGame(aiPiece); // AI wins } else if (checkDraw()) { endGame(0); // Draw } else { // --- Game Continues: Switch to Player's Turn --- turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; isAiComputing = false; // Allow player input again } } else { // --- Handle AI Error / No Move Found --- console.error(\"AI selected an invalid move, no move found, or spot taken.\", bestMove); // Fallback logic... (unchanged) let foundFallback = false; for (let i = 0; i < boardSize; i++){ /* ... */ } if (!foundFallback && !gameOver) { endGame(0); } isAiComputing = false; } }, 50); } // =========================================== // Event Listeners (Unchanged) // =========================================== canvas.addEventListener('click', function(e) { /* ... unchanged ... */ }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // Initial setup on page load // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; // Make scores accessible (though evaluateBoardState is now self-contained) // window.scores = scores; // Optional restartGame(); // Start in the initial \"choose side\" state } initializeGame(); // Run the initialization })(); 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。"}]