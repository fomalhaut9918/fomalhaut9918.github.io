[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"五子棋游戏 (AI终极版 - Web Worker)","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。支持两步确认落子。电脑最后一次落子处以红色圆环标出。 /* 页面基础样式 */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。 (function() { // --- 配置 --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // 搜索深度 (Web Worker使其可行, 但仍需时间) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // 候选走法搜索半径 // --- DOM 元素 --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- 游戏状态 (主线程) --- let board = []; let turn = \"\"; let gameOver = true; let playerIsBlack = true; let playerPiece = 1; // 1: 黑 let aiPiece = 2; // 2: 白 let isAiComputing = false; let pendingMove = null; let lastComputerMove = null; let ZOBRIST_TABLE = []; // Zobrist Hashing 表 (主线程维护) let ZOBRIST_HASH = 0; // 当前局面的 Zobrist Hash (主线程维护) let aiWorker = null; // Web Worker 实例 const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Web Worker 代码 (嵌入为字符串) // =========================================== const workerCode = ` // --- Worker Global Constants & Variables --- const boardSize = ${boardSize}; const WIN_CONDITION = ${WIN_CONDITION}; const CANDIDATE_RADIUS = ${CANDIDATE_RADIUS}; const MAX_DEPTH_WORKER = ${MAX_DEPTH}; // Use constant passed if needed // --- Zobrist (Worker Internal) --- let ZOBRIST_TABLE_WORKER = []; let ZOBRIST_HASH_WORKER = 0; let transpositionTable = new Map(); function initZobristWorker(tableData) { ZOBRIST_TABLE_WORKER = tableData; // Use table from main thread ZOBRIST_HASH_WORKER = 0; // Reset internal hash when table changes transpositionTable.clear(); // Clear TT when table changes //console.log(\"Worker: Zobrist table initialized/updated.\"); } function updateZobristWorker(i, j, piece) { if (piece === 1 || piece === 2) { ZOBRIST_HASH_WORKER = (ZOBRIST_HASH_WORKER + ZOBRIST_TABLE_WORKER[i][j][piece - 1]) % Number.MAX_SAFE_INTEGER; } } function revertZobristWorker(i, j, piece) { if (piece === 1 || piece === 2) { ZOBRIST_HASH_WORKER = (ZOBRIST_HASH_WORKER - ZOBRIST_TABLE_WORKER[i][j][piece - 1] + Number.MAX_SAFE_INTEGER) % Number.MAX_SAFE_INTEGER; } } // --- Note: Worker needs its own makeMove/undoMove using its internal hash --- function makeMoveWorker(board, i, j, piece) { if (board[i][j] === 0) { board[i][j] = piece; updateZobristWorker(i, j, piece); return true; } return false; } function undoMoveWorker(board, i, j) { const piece = board[i][j]; if (piece !== 0) { board[i][j] = 0; revertZobristWorker(i, j, piece); } } // --- Pattern Scores (Worker Internal) --- const PATTERN_SCORES = { /* ... (复制上面版本完整的 PATTERN_SCORES 对象) ... */ '11111': 100000000, '011110': 5000000, '011112': 100000, '211110': 100000, '01110': 80000, '010110': 70000, '011010': 70000, '21110': 5000, '01112': 5000, '210110': 4000, '011012': 4000, '211010': 4000, '010112': 4000, '001100': 700, '01010': 650, '010010': 600, '21100': 100, '00112': 100, '21010': 90, '01012': 90, '210010': 80, '010012': 80, '00100': 10, '21000': 5, '00012': 5, '22222': -1000000000, '022220': -50000000, '022221': -1000000, '122220': -1000000, '02220': -800000, '020220': -700000, '022020': -700000, '12220': -50000, '02221': -50000, '120220': -40000, '022021': -40000, '122020': -40000, '020221': -40000, '002200': -7000, '02020': -6500, '020020': -6000, '12200': -1000, '00221': -1000, '12020': -900, '02021': -900, '120020': -800, '020021': -800, '00200': -100, '12000': -50, '00021': -50 }; // --- Evaluation Function (Worker Internal) --- function evaluateBoardState(boardState, currentPlayer) { /* ... (复制上面版本完整的 evaluateBoardState 函数) ... */ let totalScore = 0; const directions = [ { dr: 1, dc: 0 }, { dr: 0, dc: 1 }, { dr: 1, dc: 1 }, { dr: 1, dc: -1 } ]; const ai = currentPlayer; const player = 3 - currentPlayer; function mapPiece(p) { if (p === ai) return 1; if (p === player) return 2; return 0; } for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { for (const { dr, dc } of directions) { let line = \"\"; let linePieces = []; for (let k = 0; k < 6; k++) { const nr = r + k * dr; const nc = c + k * dc; if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) { const boardPiece = boardState[nr][nc]; line += mapPiece(boardPiece); linePieces.push(boardPiece); } else { line += 'X'; linePieces.push(-1); break; } } if (line.length < 5) continue; let pattern5 = line.substring(0, 5); if (PATTERN_SCORES[pattern5]) { totalScore += PATTERN_SCORES[pattern5]; continue; } if (line.length === 6) { let pattern6 = line; if (PATTERN_SCORES[pattern6]) { totalScore += PATTERN_SCORES[pattern6]; } else { if (pattern6.startsWith('X') && PATTERN_SCORES[pattern6.substring(1)]) { totalScore += PATTERN_SCORES[pattern6.substring(1)]; } else if (pattern6.endsWith('X') && PATTERN_SCORES[pattern6.substring(0, 5)]) { totalScore += PATTERN_SCORES[pattern6.substring(0, 5)]; } } } else if (line.length === 5) { const prev_r = r - dr; const prev_c = c - dc; let prevChar = 'X'; if (prev_r >= 0 && prev_r < boardSize && prev_c >= 0 && prev_c < boardSize && boardState[prev_r][prev_c] === 0) { prevChar = '0'; } let pattern6_prev = prevChar + line; if (PATTERN_SCORES[pattern6_prev]) { totalScore += PATTERN_SCORES[pattern6_prev]; } } } } } return totalScore; } // --- Candidate Move Generation (Worker Internal) --- function getCandidateMoves(boardState, currentPlayer) { /* ... (复制上面版本完整的 getCandidateMoves 函数) ... */ let candidates = []; let immediateWins = []; let opponentWinsBlock = []; let aiLiveThrees = []; let oppLiveThreesBlock = []; let otherMoves = new Map(); const ai = currentPlayer; const player = 3 - currentPlayer; const center = Math.floor(boardSize / 2); let hasStones = false; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) { boardState[i][j] = ai; let aiScoreAfterMove = evaluateBoardState(boardState, ai); if (aiScoreAfterMove >= PATTERN_SCORES['011110']) { immediateWins.push({ i, j, score: aiScoreAfterMove * 10 }); } else if (aiScoreAfterMove >= PATTERN_SCORES['01110']) { aiLiveThrees.push({ i, j, score: aiScoreAfterMove * 1.5 }); } boardState[i][j] = 0; boardState[i][j] = player; let playerScoreAfterMove = evaluateBoardState(boardState, player); if (Math.abs(playerScoreAfterMove) >= Math.abs(PATTERN_SCORES['022220'])) { opponentWinsBlock.push({ i, j, score: Math.abs(playerScoreAfterMove) * 5 }); } else if (Math.abs(playerScoreAfterMove) >= Math.abs(PATTERN_SCORES['02220'])) { oppLiveThreesBlock.push({ i, j, score: Math.abs(playerScoreAfterMove) * 1.2 }); } boardState[i][j] = 0; } else { hasStones = true; } } } if (immediateWins.length > 0) return immediateWins; if (opponentWinsBlock.length > 0) return opponentWinsBlock; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { for (let di = -CANDIDATE_RADIUS; di bestValue) { bestValue = currentEval; bestMoveForTT = move; } alpha = Math.max(alpha, bestValue); if (beta"},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"}]