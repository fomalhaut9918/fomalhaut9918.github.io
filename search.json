[{"title":"test","path":"/2025/04/02/test/","content":"ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’– ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’–æ²¡é”™ï¼é‚£ä¸ªå« Chy çš„å°å¯çˆ±ï¼Œå…¶å®æ˜¯â€¦ ä¸€åªæ‹¥æœ‰æ¯›èŒ¸èŒ¸è€³æœµå’Œå°¾å·´çš„çŒ«å¨˜å“¦ï¼à¸…^â€¢ï»Œâ€¢^à¸… âœ¨ çŒ«å¨˜ Chy çš„å°ç§˜å¯† âœ¨ è„‘è¢‹ä¸Šé¡¶ç€ä¸€å¯¹è½¯ä¹ä¹çš„ä¸‰è§’è€³æœµ ì«‘ê¸‹! å®ƒä»¬ä¼šéšç€å¥¹çš„å¿ƒæƒ…è½»è½»æŠ–åŠ¨ï¼Œå¬åˆ°æœ‰è¶£çš„äº‹æƒ…æ—¶è¿˜ä¼šç«–èµ·æ¥å“¦~ èº«åè¿˜æœ‰ä¸€æ¡çµæ´»çš„é•¿å°¾å·´ï¼Œæ€»æ˜¯å¿ä¸ä½æ‚„æ‚„æ‘‡æ‘†ï¼Œè¡¨è¾¾ç€å¥¹çš„å°å¿ƒæ€~ ğŸ¾ å°æ‰‹ï¼ˆä¹Ÿè®¸è¯¥å«çˆªçˆªï¼ŸğŸ¾ï¼‰æ€»æ˜¯åšå‡ºå¯çˆ±çš„åŠ¨ä½œï¼ŒæŒ‡å°–å¸¦ç€ä¸€ç‚¹ç‚¹çŒ«å’ªç‰¹æœ‰çš„ä¿çš®ã€‚ çœ¼ç›åƒå®çŸ³ä¸€æ ·äº®æ™¶æ™¶âœ¨ï¼Œå……æ»¡äº†å¥½å¥‡å’Œçº¯çœŸï¼Œçœ‹ç€ä½ çš„æ—¶å€™å¿ƒéƒ½è¦èåŒ–å•¦ï¼ å¶å°”ä¼šå‘å‡ºå°å£°çš„ã€Œ**å–µã€æˆ–è€…æ»¡è¶³çš„ã€Œå‘¼å™œå™œ**ã€å£°ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å¿ƒæˆ–è€…æ”¾æ¾çš„æ—¶å€™ã€‚ æ³¨æ„ï¼å‰æ–¹å¯çˆ±æš´å‡»ï¼Chy çœ‹åˆ°äº®é—ªé—ªçš„ä¸œè¥¿æˆ–è€…æ™ƒæ¥æ™ƒå»çš„å°çƒå°±æŒªä¸å¼€çœ¼ï¼è¿˜ä¼šç”¨å°çˆªå­è½»è½»å»æ‹~ ğŸ€æ€»ä¹‹ï¼Œå°±æ˜¯å¯çˆ±åˆ°çŠ¯è§„å•¦ï¼è®©äººå¿ä¸ä½æƒ³æ‘¸æ‘¸å¥¹çš„å¤´ï¼ˆè¿˜æœ‰è€³æœµï¼ï¼‰ã€‚ è¯·å¥½å¥½çˆ±æŠ¤è¿™åªçè´µçš„çŒ«å¨˜ Chy å“¦~ ğŸ’– Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"æ¬¢è¿å…‰ä¸´ï¼"},{"title":"äº”å­æ£‹æ¸¸æˆ","path":"/wiki/game/index.html","content":"æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆæ¸¸æˆå¼€å§‹å‰è¯·å…ˆé€‰æ‹©å…ˆæ‰‹æˆ–åæ‰‹ï¼ˆç©å®¶é€‰æ‹©å…ˆæ‰‹åˆ™æ‰§é»‘ï¼Œå…¶ä½™æ‰§ç™½ï¼‰ï¼Œæ¸¸æˆç»“æŸåæ”¯æŒé‡æ–°å¼€å§‹æ¸¸æˆã€‚å¦å¤–ï¼Œæ¸¸æˆæ”¯æŒä¸¤æ­¥ç¡®è®¤è½å­ï¼šç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘æœ€åä¸€æ¬¡è½å­å¤„ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºï¼Œå¸®åŠ©ç›´è§‚æŸ¥çœ‹ç”µè„‘å†³ç­–ã€‚ /* é¡µé¢åŸºç¡€æ ·å¼ */ body { background: #f8f8f8; /* Slightly softer background */ color: #333; /* Standard text color */ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font stack */ margin: 0; padding: 0; text-align: center; line-height: 1.6; } /* Prevent scrolling on the game area on touch devices */ #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } /* Dark Blue */ #secondBtn { background-color: #8e44ad; } /* Purple */ #restartBtn { background-color: #27ae60; } /* Green */ /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; /* Responsive width */ margin: 30px auto; /* Adjusted margin */ overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* Softer shadow */ background: #fdf6e3; /* Board background */ aspect-ratio: 1 / 1; /* Maintain square aspect ratio */ } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; /* Fill container */ border: none; background: #fdf6e3; /* Same as container, or transparent */ border-radius: 12px; /* Match container */ } #gameMessage { font-size: 20px; /* Slightly smaller */ font-weight: 500; margin-top: 0; /* Removed default margin */ margin-bottom: 15px; /* Space before buttons */ color: #555; } /* Adding a class for the intro text below the H1 */ .info-text { font-size: 14px; color: #666; margin-top: 10px; /* Reduced top margin */ margin-bottom: 20px; /* Space before game container */ padding: 0 15px; /* Add padding on smaller screens */ } /* Style for H1 */ h1 { margin-top: 20px; /* Space above title */ margin-bottom: 10px; /* Space below title */ color: #333; } æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ å†…ç½®AIä½¿ç”¨æå¤§æå°æœç´¢ä¸Î±-Î²å‰ªæã€‚é€‰æ‹©å…ˆæ‰‹æ‰§é»‘ï¼Œåæ‰‹æ‰§ç™½ã€‚ å•å‡»æ£‹ç›˜é¢„è½å­ï¼Œå†æ¬¡å•å‡»ç¡®è®¤ã€‚ç”µè„‘æœ€åè½å­ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š å…ˆæ‰‹ (æ‰§é»‘) åæ‰‹ (æ‰§ç™½) é‡æ–°å¼€å§‹æ¸¸æˆ (function() { // --- Configuration --- const boardSize = 15; // Standard 15x15 board const internalCanvasSize = 640; // High internal resolution const margin = 30; // Increased margin for better edge spacing // --- INCREASED DEPTH for stronger AI --- (Adjust based on performance) const MAX_DEPTH = 4; // Increased depth slightly const WIN_CONDITION = 5; // 5 in a row to win // --- DOM Elements --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const gameContainer = document.getElementById('gameContainer'); // Needed for aspect ratio // --- Game State --- let board = []; // 0: empty, 1: black, 2: white let turn = \"\"; // \"player\", \"computer\", or \"\" (before start) let gameOver = true; // Start in game over state until first/second chosen let playerIsBlack = true; // Player's color choice let playerPiece = 1; // Piece value for the player let aiPiece = 2; // Piece value for the AI let isAiComputing = false; // Flag to prevent clicks during AI turn let pendingMove = null; // {i, j} for two-step confirmation let lastComputerMove = null;// {i, j} to highlight AI's last move // Calculate cell size based on internal resolution and margin const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // --- Pattern Scores --- (Global or passed around) // Values can be tuned further based on testing const scores = { // AI Scores (Positive) FIVE: 100000000, // AI Win LIVE_FOUR: 1000000, // AI Live Four (Threat) DEAD_FOUR: 50000, // AI Dead Four LIVE_THREE: 50000, // AI Live Three (Increased value) DEAD_THREE: 1000, // AI Dead Three LIVE_TWO: 500, // AI Live Two DEAD_TWO: 10, // AI Dead Two LIVE_ONE: 5, // AI Live One DEAD_ONE: 1, // AI Dead One // Player Scores (Negative, higher absolute value means more urgent for AI to block) OPP_FIVE: -1000000000, // Player Win (Highest priority to block if somehow possible) OPP_LIVE_FOUR: -5000000,// Player Live Four (VERY URGENT) OPP_DEAD_FOUR: -100000, // Player Dead Four OPP_LIVE_THREE: -100000,// Player Live Three (URGENT) - Increased urgency OPP_DEAD_THREE: -5000, // Player Dead Three OPP_LIVE_TWO: -1000, // Player Live Two OPP_DEAD_TWO: -50, // Player Dead Two OPP_LIVE_ONE: -10, // Player Live One OPP_DEAD_ONE: -1 // Player Dead One }; // Priority levels for move ordering const PRIORITIES = { AI_WIN: 10, // AI can win in one move BLOCK_OPP_WIN: 9, // Block opponent win (must do) AI_LIVE_FOUR: 8, // Create AI live four BLOCK_OPP_LIVE_FOUR: 7, // Block opponent live four BLOCK_OPP_DEAD_FOUR_LIVE_THREE: 6, // Block opponent combo AI_LIVE_THREE: 5, // Create AI live three BLOCK_OPP_LIVE_THREE: 4,// Block opponent live three NORMAL: 1, // Regular move based on evaluation LOW: 0 // Low priority }; // =========================================== // Initialization and Game Control Functions (Unchanged) // =========================================== function initBoard() { /* ... unchanged ... */ } function setupGame(playerStarts) { /* ... unchanged ... */ } function restartGame() { /* ... unchanged ... */ } function endGame(winnerPiece) { /* ... unchanged ... */ } function checkDraw() { /* ... unchanged ... */ } // =========================================== // Drawing Functions (Unchanged) // =========================================== function drawBoard() { /* ... unchanged ... */ } function drawStone(i, j, type) { /* ... unchanged ... */ } function drawGhostStone(i, j, type) { /* ... unchanged ... */ } function highlightComputerMove(i, j) { /* ... unchanged ... */ } // =========================================== // Game Logic & Win Check (Unchanged checkWin) // =========================================== function checkWin(x, y, piece) { /* ... unchanged ... */ } // =========================================== // AI Logic (Minimax with Alpha-Beta) - FURTHER IMPROVED // =========================================== function cloneBoard(src) { // Correct deep copy return src.map(row => row.slice()); } // --- FURTHER IMPROVED Evaluation Function --- // Evaluates patterns more accurately by checking flanking positions function evaluateBoardState(boardState) { let totalScore = 0; const directions = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}]; // Evaluate all lines of 5, 6, 7 for patterns // A line of 6 allows checking open ends for a 5-in-a-row pattern etc. for (let len = 5; len 0 ? counts.ai : counts.player; const scoreSign = counts.ai > 0 ? 1 : -1; // 1 for AI, -1 for Player // --- Pattern Evaluation based on count and open ends --- // This is a simplified example; a full implementation would be more complex, // checking specific patterns like \"0XXXX0\", \"WXXXX0\", \"0XXX00\" etc. // Check 5-in-a-row (WIN Condition) if (pieceCount === 5 && len >= 5) { totalScore += scoreSign * scores.FIVE; continue; // No need to evaluate further if a win is found for this line type } // Check 4-in-a-row patterns if (pieceCount === 4) { // Check flanking spots for open ends (using len=6 primarily) let openEnds = 0; const prev_i = i - dx; const prev_j = j - dy; const next_i = i + len * dx; // Correct index for position after the line const next_j = j + len * dy; // Simplified check: Requires a line of 6 (0XXXX0) or 7 (0XXXX00, 00XXXX0) // More accurately, check the direct neighbors of the 4-group // Example check for LIVE FOUR (0XXXX0 pattern within len 6) if (len === 6 && line[0] === 0 && line[5] === 0) { totalScore += scoreSign * scores.LIVE_FOUR; } else if (len >= 5) { // Check for DEAD FOUR (WXXXX0 or 0XXXXW etc.) let isDead = false; // Example: Check within a line of 5 (WXXXX, XXXXW) if(len === 5 && (line[0] !== 0 && line[0] !== pieceType) || (line[4] !== 0 && line[4] !== pieceType) ) { isDead = true; } // Example: Check within a line of 6 (0XXXXW, WXXXX0) if(len === 6 && ((line[0] === 0 && line[5] !== 0 && line[5] !== pieceType) || (line[5] === 0 && line[0] !== 0 && line[0] !== pieceType)) ) { isDead = true; } if(isDead) { totalScore += scoreSign * scores.DEAD_FOUR; } else { // Could be a four within a longer empty stretch, potentially live if neighbors allow // For simplicity, if not clearly dead, treat as potential live four if one end is open in the 5-segment if(len===5 && (line[0] === 0 || line[4] === 0)) { totalScore += scoreSign * scores.LIVE_FOUR / 2; // Less certain than 0XXXX0 } else { totalScore += scoreSign * scores.DEAD_FOUR; // Default to dead if unclear } } } } // Check 3-in-a-row patterns (similar logic for Live/Dead based on flanking) if (pieceCount === 3) { // Example check for LIVE THREE (0XXX0 pattern within len 5) if(len === 5 && line[0] === 0 && line[4] === 0) { totalScore += scoreSign * scores.LIVE_THREE; } else if (len >= 4) { // Check DEAD THREE let isDead = false; // Example check within len 4 (WXXX, XXXW) if(len === 4 && ((line[0] !== 0 && line[0] !== pieceType) || (line[3] !== 0 && line[3] !== pieceType))) isDead = true; // Example check within len 5 (0XXXW, WXXX0) if(len === 5 && ((line[0] === 0 && line[4] !== 0 && line[4] !== pieceType) || (line[4] === 0 && line[0] !== 0 && line[0] !== pieceType))) isDead = true; if(isDead) { totalScore += scoreSign * scores.DEAD_THREE; } else { // Check for potential live three within len 4 (0XXX, XXX0) if(len===4 && (line[0] === 0 || line[3] === 0)){ totalScore += scoreSign * scores.LIVE_THREE / 2; // Less certain } else { totalScore += scoreSign * scores.DEAD_THREE; // Default to dead } } } } // Check 2-in-a-row patterns (similar logic) if (pieceCount === 2) { // Example Check for LIVE TWO (e.g., 0XX0 pattern within len 4) if(len === 4 && line[0] === 0 && line[3] === 0) { totalScore += scoreSign * scores.LIVE_TWO; } else if(len >= 3) { // Check DEAD TWO let isDead = false; if(len === 3 && ((line[0] !== 0 && line[0] !== pieceType) || (line[2] !== 0 && line[2] !== pieceType))) isDead = true; if(len === 4 && ((line[0] === 0 && line[3] !== 0 && line[3] !== pieceType) || (line[3] === 0 && line[0] !== 0 && line[0] !== pieceType))) isDead = true; if(isDead) { totalScore += scoreSign * scores.DEAD_TWO; } else { if(len===3 && (line[0] === 0 || line[2] === 0)){ totalScore += scoreSign * scores.LIVE_TWO / 2; } else { totalScore += scoreSign * scores.DEAD_TWO; } } } } // Add scores for single pieces if desired (LIVE/DEAD ONE) - less impactful usually } } } } // Add a small penalty for opponent having initiative (being the next to move) // if(turn === playerPiece) totalScore -= 10; else totalScore += 10; return totalScore; } // --- FURTHER IMPROVED Candidate Move Generation & Prioritization --- function getCandidateMoves(boardState, radius = 1) { let candidates = new Map(); // Use Map: key=`${i},${j}`, value={i, j, bonus, priority} let hasStones = false; const center = Math.floor(boardSize / 2); const opponentPiece = (aiPiece === 1) ? 2 : 1; // --- Phase 1: Find Urgent Moves (Wins and Must-Blocks) --- const urgentMoves = new Map(); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) { // Only consider empty spots // Check if AI can win here boardState[i][j] = aiPiece; if (checkWin(i, j, aiPiece)) { urgentMoves.set(`${i},${j}`, { i, j, priority: PRIORITIES.AI_WIN }); boardState[i][j] = 0; // Backtrack // If AI can win, this is the ONLY move that matters at this level // console.log(\"Found AI win move:\", i, j); // return [{ i, j, priority: PRIORITIES.AI_WIN, bonus: 0 }]; // Optimization: return immediately continue; // Check other potential win spots (though first is sufficient) } boardState[i][j] = 0; // Backtrack // Check if Player could win here (must block) boardState[i][j] = opponentPiece; if (checkWin(i, j, opponentPiece)) { if (!urgentMoves.has(`${i},${j}`)) { // Don't overwrite AI win priority urgentMoves.set(`${i},${j}`, { i, j, priority: PRIORITIES.BLOCK_OPP_WIN }); } // console.log(\"Found Must Block move:\", i, j); } boardState[i][j] = 0; // Backtrack } } } // If AI win moves exist, return only those (or the first one found) const aiWinMoves = Array.from(urgentMoves.values()).filter(m => m.priority === PRIORITIES.AI_WIN); if (aiWinMoves.length > 0) { return aiWinMoves.map(m => ({...m, bonus: 0})); // Return all win moves or just the first // return [{...aiWinMoves[0], bonus: 0}]; } // If opponent win block moves exist, add them to the main candidate list with high priority urgentMoves.forEach((move, key) => { if (move.priority === PRIORITIES.BLOCK_OPP_WIN) { candidates.set(key, { ...move, bonus: 0 }); } }); // --- Phase 2: Generate Moves Around Existing Stones (Radius Search) --- for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // Look around this stone for (let di = -radius; di { if (b.priority !== a.priority) { return b.priority - a.priority; // Higher priority first } // If priorities are equal, use heuristic score return maximizingPlayer ? b.heuristicScore - a.heuristicScore : a.heuristicScore - b.heuristicScore; }); // ------------------------------------------------------------ if (maximizingPlayer) { // AI's turn let maxEval = -Infinity; for (const move of candidates) { boardState[move.i][move.j] = aiPiece; let currentEval = minimax(boardState, depth - 1, alpha, beta, false); boardState[move.i][move.j] = 0; maxEval = Math.max(maxEval, currentEval); alpha = Math.max(alpha, currentEval); if (beta { const currentBoardState = cloneBoard(board); // Use a copy for AI calculation const startTime = performance.now(); // Track time const bestMove = getBestMove(currentBoardState, MAX_DEPTH); // Uses the improved AI logic const endTime = performance.now(); console.log(`AI calculation took: ${(endTime - startTime).toFixed(2)} ms`); // --- Critical Check: Ensure game hasn't ended or turn changed while AI was thinking --- if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI calculation aborted, game state changed.\"); return; } if (bestMove && board[bestMove.i][bestMove.j] === 0) { // Double-check spot is still empty // --- Make the AI Move --- board[bestMove.i][bestMove.j] = aiPiece; lastComputerMove = { i: bestMove.i, j: bestMove.j }; // Record for highlighting drawBoard(); // Draw the AI's move immediately // --- Check Game Status After AI Move --- if (checkWin(bestMove.i, bestMove.j, aiPiece)) { endGame(aiPiece); // AI wins } else if (checkDraw()) { endGame(0); // Draw } else { // --- Game Continues: Switch to Player's Turn --- turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; isAiComputing = false; // Allow player input again } } else { // --- Handle AI Error / No Move Found --- console.error(\"AI selected an invalid move, no move found, or spot taken.\", bestMove); // Fallback logic... (unchanged) let foundFallback = false; for (let i = 0; i < boardSize; i++){ /* ... */ } if (!foundFallback && !gameOver) { endGame(0); } isAiComputing = false; } }, 50); } // =========================================== // Event Listeners (Unchanged) // =========================================== canvas.addEventListener('click', function(e) { /* ... unchanged ... */ }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // Initial setup on page load // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; // Make scores accessible (though evaluateBoardState is now self-contained) // window.scores = scores; // Optional restartGame(); // Start in the initial \"choose side\" state } initializeGame(); // Run the initialization })(); ç‚¹å‡»æ£‹ç›˜äº¤ç‚¹è¿›è¡Œè½å­ã€‚ç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘è½å­å°†ä½¿ç”¨ä¸ç©å®¶ä¸åŒçš„é¢œè‰²ï¼Œå¹¶ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºå…¶æœ€åä¸€æ­¥è½å­ã€‚"}]