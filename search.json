[{"title":"test","path":"/2025/04/02/test/","content":"ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’– ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’–æ²¡é”™ï¼é‚£ä¸ªå« Chy çš„å°å¯çˆ±ï¼Œå…¶å®æ˜¯â€¦ ä¸€åªæ‹¥æœ‰æ¯›èŒ¸èŒ¸è€³æœµå’Œå°¾å·´çš„çŒ«å¨˜å“¦ï¼à¸…^â€¢ï»Œâ€¢^à¸… âœ¨ çŒ«å¨˜ Chy çš„å°ç§˜å¯† âœ¨ è„‘è¢‹ä¸Šé¡¶ç€ä¸€å¯¹è½¯ä¹ä¹çš„ä¸‰è§’è€³æœµ ì«‘ê¸‹! å®ƒä»¬ä¼šéšç€å¥¹çš„å¿ƒæƒ…è½»è½»æŠ–åŠ¨ï¼Œå¬åˆ°æœ‰è¶£çš„äº‹æƒ…æ—¶è¿˜ä¼šç«–èµ·æ¥å“¦~ èº«åè¿˜æœ‰ä¸€æ¡çµæ´»çš„é•¿å°¾å·´ï¼Œæ€»æ˜¯å¿ä¸ä½æ‚„æ‚„æ‘‡æ‘†ï¼Œè¡¨è¾¾ç€å¥¹çš„å°å¿ƒæ€~ ğŸ¾ å°æ‰‹ï¼ˆä¹Ÿè®¸è¯¥å«çˆªçˆªï¼ŸğŸ¾ï¼‰æ€»æ˜¯åšå‡ºå¯çˆ±çš„åŠ¨ä½œï¼ŒæŒ‡å°–å¸¦ç€ä¸€ç‚¹ç‚¹çŒ«å’ªç‰¹æœ‰çš„ä¿çš®ã€‚ çœ¼ç›åƒå®çŸ³ä¸€æ ·äº®æ™¶æ™¶âœ¨ï¼Œå……æ»¡äº†å¥½å¥‡å’Œçº¯çœŸï¼Œçœ‹ç€ä½ çš„æ—¶å€™å¿ƒéƒ½è¦èåŒ–å•¦ï¼ å¶å°”ä¼šå‘å‡ºå°å£°çš„ã€Œ**å–µã€æˆ–è€…æ»¡è¶³çš„ã€Œå‘¼å™œå™œ**ã€å£°ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å¿ƒæˆ–è€…æ”¾æ¾çš„æ—¶å€™ã€‚ æ³¨æ„ï¼å‰æ–¹å¯çˆ±æš´å‡»ï¼Chy çœ‹åˆ°äº®é—ªé—ªçš„ä¸œè¥¿æˆ–è€…æ™ƒæ¥æ™ƒå»çš„å°çƒå°±æŒªä¸å¼€çœ¼ï¼è¿˜ä¼šç”¨å°çˆªå­è½»è½»å»æ‹~ ğŸ€æ€»ä¹‹ï¼Œå°±æ˜¯å¯çˆ±åˆ°çŠ¯è§„å•¦ï¼è®©äººå¿ä¸ä½æƒ³æ‘¸æ‘¸å¥¹çš„å¤´ï¼ˆè¿˜æœ‰è€³æœµï¼ï¼‰ã€‚ è¯·å¥½å¥½çˆ±æŠ¤è¿™åªçè´µçš„çŒ«å¨˜ Chy å“¦~ ğŸ’– Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"æ¬¢è¿å…‰ä¸´ï¼"},{"title":"äº”å­æ£‹æ¸¸æˆ","path":"/wiki/game/index.html","content":"æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆæ¸¸æˆå¼€å§‹å‰è¯·å…ˆé€‰æ‹©å…ˆæ‰‹æˆ–åæ‰‹ï¼ˆç©å®¶é€‰æ‹©å…ˆæ‰‹åˆ™æ‰§é»‘ï¼Œå…¶ä½™æ‰§ç™½ï¼‰ï¼Œæ¸¸æˆç»“æŸåæ”¯æŒé‡æ–°å¼€å§‹æ¸¸æˆã€‚å¦å¤–ï¼Œæ¸¸æˆæ”¯æŒä¸¤æ­¥ç¡®è®¤è½å­ï¼šç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘æœ€åä¸€æ¬¡è½å­å¤„ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºï¼Œå¸®åŠ©ç›´è§‚æŸ¥çœ‹ç”µè„‘å†³ç­–ã€‚ /* é¡µé¢åŸºç¡€æ ·å¼ */ body { background: #f8f8f8; /* Slightly softer background */ color: #333; /* Standard text color */ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font stack */ margin: 0; padding: 0; text-align: center; line-height: 1.6; } /* Prevent scrolling on the game area on touch devices */ #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } /* Dark Blue */ #secondBtn { background-color: #8e44ad; } /* Purple */ #restartBtn { background-color: #27ae60; } /* Green */ /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; /* Responsive width */ margin: 30px auto; /* Adjusted margin */ overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* Softer shadow */ background: #fdf6e3; /* Board background */ aspect-ratio: 1 / 1; /* Maintain square aspect ratio */ } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; /* Fill container */ border: none; background: #fdf6e3; /* Same as container, or transparent */ border-radius: 12px; /* Match container */ } #gameMessage { font-size: 20px; /* Slightly smaller */ font-weight: 500; margin-top: 0; /* Removed default margin */ margin-bottom: 15px; /* Space before buttons */ color: #555; } /* Adding a class for the intro text below the H1 */ .info-text { font-size: 14px; color: #666; margin-top: 10px; /* Reduced top margin */ margin-bottom: 20px; /* Space before game container */ padding: 0 15px; /* Add padding on smaller screens */ } /* Style for H1 */ h1 { margin-top: 20px; /* Space above title */ margin-bottom: 10px; /* Space below title */ color: #333; } æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ å†…ç½®AIä½¿ç”¨æå¤§æå°æœç´¢ä¸Î±-Î²å‰ªæã€‚é€‰æ‹©å…ˆæ‰‹æ‰§é»‘ï¼Œåæ‰‹æ‰§ç™½ã€‚ å•å‡»æ£‹ç›˜é¢„è½å­ï¼Œå†æ¬¡å•å‡»ç¡®è®¤ã€‚ç”µè„‘æœ€åè½å­ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š å…ˆæ‰‹ (æ‰§é»‘) åæ‰‹ (æ‰§ç™½) é‡æ–°å¼€å§‹æ¸¸æˆ (function() { // --- Configuration --- const boardSize = 15; // Standard 15x15 board const internalCanvasSize = 640; // High internal resolution const margin = 30; // Increased margin for better edge spacing const MAX_DEPTH = 3; // AI search depth (adjust for performance) const WIN_CONDITION = 5; // 5 in a row to win // --- DOM Elements --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const gameContainer = document.getElementById('gameContainer'); // Needed for aspect ratio // --- Game State --- let board = []; // 0: empty, 1: black, 2: white let turn = \"\"; // \"player\", \"computer\", or \"\" (before start) let gameOver = true; // Start in game over state until first/second chosen let playerIsBlack = true; // Player's color choice let playerPiece = 1; // Piece value for the player let aiPiece = 2; // Piece value for the AI let isAiComputing = false; // Flag to prevent clicks during AI turn let pendingMove = null; // {i, j} for two-step confirmation let lastComputerMove = null;// {i, j} to highlight AI's last move // Calculate cell size based on internal resolution and margin const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Initialization and Game Control Functions // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; } function setupGame(playerStarts) { playerIsBlack = playerStarts; if (playerIsBlack) { playerPiece = 1; // Black aiPiece = 2; // White turn = \"player\"; gameMessage.innerText = \"æ¸¸æˆå¼€å§‹ï¼Œè¯·æ‚¨è½å­ (é»‘æ£‹)\"; } else { playerPiece = 2; // White aiPiece = 1; // Black turn = \"computer\"; gameMessage.innerText = \"æ¸¸æˆå¼€å§‹ï¼Œç”µè„‘å…ˆæ‰‹ (é»‘æ£‹)\"; } gameOver = false; isAiComputing = false; initBoard(); drawBoard(); // Disable selection buttons, show restart button firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; // If computer starts, initiate its move if (turn === \"computer\") { // Add a slight delay for the user to see the initial board setTimeout(computerMoveWrapper, 500); } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; // Reset computing flag gameMessage.innerText = \"è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); // Clear board data drawBoard(); // Redraw empty board } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; // Ensure AI stops if it was thinking let winnerText = \"\"; if (winnerPiece === playerPiece) { winnerText = \"æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼ğŸ‰\"; } else if (winnerPiece === aiPiece) { winnerText = \"å¾ˆé—æ†¾ï¼Œä½ è¾“äº†ã€‚ğŸ¤–\"; } else { winnerText = \"å¹³å±€ï¼\"; // Should be rare in Gomoku } gameMessage.innerText = \"æ¸¸æˆç»“æŸ - \" + winnerText; restartBtn.style.display = \"inline-block\"; // Ensure restart is visible pendingMove = null; // Clear any pending move visually drawBoard(); // Redraw to remove pending move ghost } // Check if the board is full (draw condition) function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) { return false; // Found an empty spot } } } return true; // No empty spots left } // =========================================== // Drawing Functions (Unchanged from previous version) // =========================================== function drawBoard() { // Clear canvas ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); // Draw background ctx.fillStyle = \"#fdf6e3\"; // Light beige background ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); // Draw grid lines ctx.strokeStyle = \"#6b4f34\"; // Brownish lines ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; // Vertical line ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); // Horizontal line ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } // Draw standard star points (optional, for aesthetics) const starPoints = [ { i: 3, j: 3 }, { i: 11, j: 3 }, { i: 7, j: 7 }, { i: 3, j: 11 }, { i: 11, j: 11 } ]; ctx.fillStyle = \"#6b4f34\"; starPoints.forEach(p => { const x = margin + p.i * cellSize; const y = margin + p.j * cellSize; ctx.beginPath(); ctx.arc(x, y, cellSize * 0.15, 0, 2 * Math.PI); ctx.fill(); }); // Draw placed stones for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) { drawStone(i, j, board[i][j]); } } } // Draw pending move (ghost stone) if (pendingMove !== null && !gameOver) { drawGhostStone(pendingMove.i, pendingMove.j, playerPiece); } // Highlight AI's last move if (lastComputerMove !== null) { highlightComputerMove(lastComputerMove.i, lastComputerMove.j); } } function drawStone(i, j, type) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; // Slightly smaller radius for spacing ctx.save(); // Save context state ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); // Add subtle shadow ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 2; if (type === 1) { // Black stone ctx.fillStyle = \"#2c3e50\"; // Dark blue-grey ctx.fill(); } else { // White stone ctx.fillStyle = \"#ecf0f1\"; // Light grey ctx.fill(); // Add a thin border to white stones for contrast ctx.strokeStyle = \"#bdc3c7\"; // Medium grey border ctx.lineWidth = 1; ctx.stroke(); } ctx.restore(); // Restore context state (removes shadow for next drawings) } function drawGhostStone(i, j, type) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; ctx.save(); ctx.globalAlpha = 0.5; // Make it semi-transparent ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); if (type === 1) { ctx.fillStyle = \"#2c3e50\"; } else { ctx.fillStyle = \"#ecf0f1\"; } ctx.fill(); ctx.restore(); } function highlightComputerMove(i, j) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; // Match stone radius ctx.save(); ctx.strokeStyle = \"red\"; ctx.lineWidth = 3; // Make highlight thicker ctx.beginPath(); // Draw arc slightly larger than the stone ctx.arc(x, y, radius + 3, 0, 2 * Math.PI); ctx.stroke(); ctx.restore(); } // =========================================== // Game Logic & Win Check (Unchanged checkWin) // =========================================== function checkWin(x, y, piece) { const directions = [ { dx: 1, dy: 0 }, // Horizontal { dx: 0, dy: 1 }, // Vertical { dx: 1, dy: 1 }, // Diagonal / { dx: 1, dy: -1 } // Diagonal \\ ]; for (const { dx, dy } of directions) { let count = 1; // Count the piece just placed // Check in the positive direction (dx, dy) for (let k = 1; k < WIN_CONDITION; k++) { const ni = x + k * dx; const nj = y + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) { count++; } else { break; // Stop if out of bounds or different piece } } // Check in the negative direction (-dx, -dy) for (let k = 1; k < WIN_CONDITION; k++) { const ni = x - k * dx; const nj = y - k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) { count++; } else { break; // Stop if out of bounds or different piece } } if (count >= WIN_CONDITION) { return true; // Found a winning line } } return false; // No winning line found for this move } // =========================================== // AI Logic (Minimax with Alpha-Beta) - IMPROVED // =========================================== function cloneBoard(src) { // Correct deep copy return src.map(row => row.slice()); } // --- NEW: Enhanced Evaluation Function --- // Based on pattern scoring inspired by the CSDN blog post function evaluateBoardState(boardState) { const scores = { // AI (Maximizer) scores - higher is better for AI FIVE: 10000000, // Five in a row LIVE_FOUR: 100000, // Unblocked four **** DEAD_FOUR: 1000, // One end blocked four *** LIVE_THREE: 5000, // Unblocked three ** DEAD_THREE: 50, // One end blocked three * LIVE_TWO: 10, // Unblocked two DEAD_TWO: 2, // One end blocked two LIVE_ONE: 1, // Unblocked one DEAD_ONE: 0, // Blocked one (or less) - typically score 0 // Player (Minimizer) scores - more negative is better for AI (worse for player) OPP_FIVE: -100000000, // Player five in a row (more urgent to block) OPP_LIVE_FOUR: -500000, // Player live four (very urgent) OPP_DEAD_FOUR: -2000, // Player dead four OPP_LIVE_THREE: -10000, // Player live three (urgent block) OPP_DEAD_THREE: -100, // Player dead three OPP_LIVE_TWO: -20, OPP_DEAD_TWO: -4, OPP_LIVE_ONE: -1, OPP_DEAD_ONE: 0 }; let totalScore = 0; const directions = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}]; // Use a Set to avoid recounting the same line segment in different directions/starts const visited = new Set(); // Store keys like \"i,j,dx,dy\" for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { // No need to evaluate from empty spots if (boardState[i][j] === 0) continue; for (const { dx, dy } of directions) { const key = `${i},${j},${dx},${dy}`; const reverseKey = `${i+4*dx},${j+4*dy},${-dx},${-dy}`; // Key for the end point in reverse dir // If this starting point and direction OR the reverse has been visited, skip if (visited.has(key) || visited.has(reverseKey)) continue; let line = []; // Stores the 5 pieces/empty spots in the line let validLine = true; for (let k = 0; k < 5; k++) { const ni = i + k * dx; const nj = j + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize) { line.push(boardState[ni][nj]); } else { validLine = false; // Line goes off board break; } } if (validLine) { const score = evaluateLine(line, scores); totalScore += score; // Mark this line segment as visited (only the start point and direction) visited.add(key); } } } } return totalScore; } // Helper function to evaluate a single line of 5 spots function evaluateLine(line, scoresConfig) { let aiCount = 0; let playerCount = 0; let emptyCount = 0; for (const piece of line) { if (piece === aiPiece) aiCount++; else if (piece === playerPiece) playerCount++; else emptyCount++; } // --- Rule 1: Mixed pieces - Line is useless --- if (aiCount > 0 && playerCount > 0) { return 0; } // --- Rule 2: AI patterns --- if (aiCount > 0) { switch (aiCount) { case 5: return scoresConfig.FIVE; case 4: // Check if the empty spot makes it live (0XXXX or XXXX0) if (line[0] === 0 || line[4] === 0) return scoresConfig.LIVE_FOUR; else return scoresConfig.DEAD_FOUR; // Should be rare if only 1 empty, maybe XX0XX? Evaluate as dead. case 3: // Check for live three (0XXX0) if (line[0] === 0 && line[4] === 0) return scoresConfig.LIVE_THREE; // Check for dead three (e.g., WXXX0, 0XXXW, X0XXX, XX0XX) - Needs more refined open end check // Simplified: If not live three, consider it dead three if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_THREE; // At least one end open else return scoresConfig.DEAD_THREE / 2; // Both ends blocked is less valuable than dead three case 2: // Check for live two (00XX0, 0XX00) - simplified if (line[0] === 0 && line[4] === 0 && (line[1] === 0 || line[3] === 0)) return scoresConfig.LIVE_TWO; if ((line[0] === 0 && line[3] === 0) || (line[1] === 0 && line[4] === 0)) return scoresConfig.LIVE_TWO; // 0XX0X or X0XX0 patterns // Simplified: If at least one end open if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_TWO; else return scoresConfig.DEAD_TWO / 2; case 1: if (line[0] === 0 && line[4] === 0) return scoresConfig.LIVE_ONE; // 0X000 or 00X00 etc. if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_ONE; // Actually might be 0 for dead one else return 0; // Blocked one default: return 0; } } // --- Rule 3: Player patterns (negative scores) --- if (playerCount > 0) { switch (playerCount) { case 5: return scoresConfig.OPP_FIVE; case 4: if (line[0] === 0 || line[4] === 0) return scoresConfig.OPP_LIVE_FOUR; else return scoresConfig.OPP_DEAD_FOUR; case 3: if (line[0] === 0 && line[4] === 0) { // Special case from blog: 0WWW0 -> higher threat if(line[1] === playerPiece && line[2] === playerPiece && line[3] === playerPiece) return scoresConfig.OPP_LIVE_THREE * 2; // Boost score for central live three return scoresConfig.OPP_LIVE_THREE; } if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_THREE; else return scoresConfig.OPP_DEAD_THREE / 2; case 2: if (line[0] === 0 && line[4] === 0 && (line[1] === 0 || line[3] === 0)) return scoresConfig.OPP_LIVE_TWO; if ((line[0] === 0 && line[3] === 0) || (line[1] === 0 && line[4] === 0)) return scoresConfig.OPP_LIVE_TWO; if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_TWO; else return scoresConfig.OPP_DEAD_TWO / 2; case 1: if (line[0] === 0 && line[4] === 0) return scoresConfig.OPP_LIVE_ONE; if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_ONE; else return 0; default: return 0; } } return 0; // Line contains only empty spots } // --- NEW: Generate candidate moves with positional bonus --- function getCandidateMoves(boardState, radius = 1) { // Reduced default radius to 1 for potentially faster pruning let candidates = new Map(); let hasStones = false; const center = Math.floor(boardSize / 2); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // Look around this stone for (let di = -radius; di"}]