[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"Some simple games","path":"/wiki/game/index.html","content":"欢迎光临！ 下面是一个贪吃蛇小游戏。 点击开始游戏 开始 /* 保持页面背景为空白 */ body { background: #fff; color: #000; font-family: Arial, sans-serif; margin: 0; padding: 0; text-align: center; } /* 禁止页面在游戏区域滚动 */ #gameContainer { touch-action: none; } /* 按钮悬停效果 */ #startBtn:hover { background-color: #222299; } (function() { const canvas = document.getElementById('snakeCanvas'); const ctx = canvas.getContext('2d'); // 每个网格单元 const box = 20; const canvasSize = 600; let snake, prevSnake, food, direction, score, gameOver; // 固定时间步长（秒） const fixedDelta = 0.1; let accumulator = 0; let lastTime = performance.now(); let running = false; const gameMessage = document.getElementById('gameMessage'); const startBtn = document.getElementById('startBtn'); // 用于手势检测的变量 let touchStartX = 0, touchStartY = 0; // 绘制圆角矩形的辅助函数 function drawRoundedRect(x, y, width, height, radius) { ctx.beginPath(); ctx.moveTo(x + radius, y); ctx.lineTo(x + width - radius, y); ctx.quadraticCurveTo(x + width, y, x + width, y + radius); ctx.lineTo(x + width, y + height - radius); ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height); ctx.lineTo(x + radius, y + height); ctx.quadraticCurveTo(x, y + height, x, y + height - radius); ctx.lineTo(x, y + radius); ctx.quadraticCurveTo(x, y, x + radius, y); ctx.closePath(); ctx.fill(); ctx.stroke(); } // 初始化游戏状态，并滚动聚焦至游戏区域 function initGame() { // 初始蛇的起始位置（存储上一次状态以用于插值） snake = [ { x: Math.floor(canvasSize / (2 * box)) * box, y: Math.floor(canvasSize / (2 * box)) * box } ]; // 克隆数组用于插值（初始时两者相等） prevSnake = JSON.parse(JSON.stringify(snake)); food = generateFood(); direction = 'right'; score = 0; gameOver = false; gameMessage.innerText = \"\"; startBtn.style.display = 'none'; document.getElementById('gameContainer').scrollIntoView({ behavior: 'smooth', block: 'center' }); lastTime = performance.now(); accumulator = 0; } // 生成不会撞到蛇的食物 function generateFood() { let foodItem; do { foodItem = { x: Math.floor(Math.random() * (canvasSize / box)) * box, y: Math.floor(Math.random() * (canvasSize / box)) * box }; } while (collision(foodItem.x, foodItem.y, snake)); return foodItem; } // 碰撞检测：判断 (x, y) 是否在数组中存在 function collision(x, y, array) { for (let i = 0; i < array.length; i++) { if (x === array[i].x && y === array[i].y) return true; } return false; } // 更新游戏逻辑：在更新前保存当前状态到 prevSnake 用于插值动画 function updateLogic() { prevSnake = JSON.parse(JSON.stringify(snake)); let head = { x: snake[0].x, y: snake[0].y }; switch(direction) { case 'left': head.x -= box; break; case 'right': head.x += box; break; case 'up': head.y -= box; break; case 'down': head.y += box; break; } // 撞墙或撞自身则判定游戏结束 if (head.x < 0 || head.y < 0 || head.x >= canvasSize || head.y >= canvasSize || collision(head.x, head.y, snake)) { gameOver = true; return; } snake.unshift(head); if (head.x === food.x && head.y === food.y) { score++; food = generateFood(); } else { snake.pop(); } } // 利用持续更新后的插值进行平滑渲染 function draw() { ctx.clearRect(0, 0, canvasSize, canvasSize); // 绘制画布背景渐变 let bgGradient = ctx.createLinearGradient(0, 0, canvasSize, canvasSize); bgGradient.addColorStop(0, '#ffffff'); bgGradient.addColorStop(1, '#ecf0f1'); ctx.fillStyle = bgGradient; ctx.fillRect(0, 0, canvasSize, canvasSize); // 设置阴影效果，用于食物和蛇的绘制 ctx.shadowColor = 'rgba(0, 0, 0, 0.2)'; ctx.shadowBlur = 6; ctx.shadowOffsetX = 2; ctx.shadowOffsetY = 2; // 绘制食物的圆角方块 ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.fillStyle = 'red'; drawRoundedRect(food.x + 2, food.y + 2, box - 4, box - 4, 4); // 绘制蛇体，采用插值平滑动画，且用渐变过渡颜色 for (let i = 0; i < snake.length; i++) { // 若上一帧数据存在，则计算插值坐标；否则直接使用当前数据 let prevPos = (prevSnake && prevSnake[i]) ? prevSnake[i] : snake[i]; let t = accumulator / fixedDelta; let interpX = prevPos.x + t * (snake[i].x - prevPos.x); let interpY = prevPos.y + t * (snake[i].y - prevPos.y); // 蛇头和身躯颜色不同，蛇头采用深色 if (i === 0) { ctx.fillStyle = '#2c3e50'; } else { // 计算渐变：靠近头部颜色更深，靠近尾部颜色较浅 let ratio = i / snake.length; let r = Math.floor(44 + ratio * (105 - 44)); // interpolate between 44 and 105 let g = Math.floor(62 + ratio * (152 - 62)); let b = Math.floor(80 + ratio * (219 - 80)); ctx.fillStyle = `rgb(${r}, ${g}, ${b})`; } ctx.strokeStyle = 'white'; // 绘制圆角蛇体块 drawRoundedRect(interpX + 2, interpY + 2, box - 4, box - 4, 4); } // 绘制分数，无阴影 ctx.shadowBlur = 0; ctx.fillStyle = 'black'; ctx.font = '20px Arial'; ctx.textAlign = 'left'; ctx.fillText(\"Score: \" + score, 5, canvasSize - 5); } // 主游戏循环：采用 requestAnimationFrame 与固定步长更新，并用插值实现平滑动画 function gameLoop(timestamp) { if (!running) return; let dt = (timestamp - lastTime) / 1000; lastTime = timestamp; accumulator += dt; while (accumulator >= fixedDelta) { if (!gameOver) { updateLogic(); } accumulator -= fixedDelta; } draw(); if (gameOver) { showGameOver(); running = false; return; } requestAnimationFrame(gameLoop); } function showGameOver() { ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\"; ctx.fillRect(0, 0, canvasSize, canvasSize); ctx.fillStyle = \"white\"; ctx.font = \"30px Arial\"; ctx.textAlign = \"center\"; ctx.fillText(\"Game Over\", canvasSize / 2, canvasSize / 2 - 20); gameMessage.innerText = \"游戏结束，最终得分：\" + score; startBtn.innerText = \"重新开始\"; startBtn.style.display = \"inline-block\"; } // 桌面端键盘操作 document.addEventListener('keydown', function(event) { if (!gameOver) { switch (event.key.toLowerCase()) { case 'w': if (direction !== 'down') direction = 'up'; break; case 'a': if (direction !== 'right') direction = 'left'; break; case 's': if (direction !== 'up') direction = 'down'; break; case 'd': if (direction !== 'left') direction = 'right'; break; } } }); // 移动端手势：通过 touchstart、touchmove 和 touchend 控制方向 canvas.addEventListener('touchstart', function(e) { e.preventDefault(); const touch = e.changedTouches[0]; touchStartX = touch.clientX; touchStartY = touch.clientY; }, {passive: false}); canvas.addEventListener('touchmove', function(e) { e.preventDefault(); }, {passive: false}); canvas.addEventListener('touchend', function(e) { const touch = e.changedTouches[0]; const deltaX = touch.clientX - touchStartX; const deltaY = touch.clientY - touchStartY; if (Math.abs(deltaX) > Math.abs(deltaY)) { if (deltaX > 20 && direction !== 'left') { direction = 'right'; } else if (deltaX < -20 && direction !== 'right') { direction = 'left'; } } else { if (deltaY > 20 && direction !== 'up') { direction = 'down'; } else if (deltaY < -20 && direction !== 'down') { direction = 'up'; } } }, {passive: false}); // 开始或重新开始游戏按钮事件 startBtn.addEventListener('click', function() { initGame(); running = true; requestAnimationFrame(gameLoop); }); gameMessage.innerText = \"点击开始游戏\"; })(); 使用键盘（WASD）或滑动手势操控方向，挑战你的反应速度！"}]