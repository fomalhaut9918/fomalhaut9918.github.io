[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏 (AI专家版)","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏 (AI专家版)内置AI再次升级，采用更精密的棋型模式匹配估价、极大极小搜索、α-β剪枝及优化的走法排序。游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。支持两步确认落子：第一次点击显示预落子效果，第二次点击确认落子。电脑最后一次落子处以红色圆环标出。 /* 页面基础样式 */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} 欢迎来到五子棋游戏 (AI专家版) 内置AI使用极大极小搜索与α-β剪枝，结合精密的棋型评估。 选择先手执黑，后手执白。单击棋盘预落子，再次单击确认。电脑最后落子以红色圆环标出。 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。 (function() { // --- 配置 --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // 搜索深度 (保持4, 但优化剪枝和评估) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // 候选走法搜索半径 // --- DOM 元素 --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- 游戏状态 --- let board = []; let turn = \"\"; let gameOver = true; let playerIsBlack = true; let playerPiece = 1; // 1: 黑 let aiPiece = 2; // 2: 白 let isAiComputing = false; let pendingMove = null; let lastComputerMove = null; let ZOBRIST_TABLE = []; // Zobrist Hashing 表 let ZOBRIST_HASH = 0; // 当前局面的 Zobrist Hash let transpositionTable = new Map(); // 置换表 const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Zobrist Hashing 初始化 // =========================================== function initZobrist() { ZOBRIST_TABLE = Array(boardSize); for (let i = 0; i < boardSize; i++) { ZOBRIST_TABLE[i] = Array(boardSize); for (let j = 0; j < boardSize; j++) { ZOBRIST_TABLE[i][j] = [ Math.floor(Math.random() * Number.MAX_SAFE_INTEGER), // 黑子 Math.floor(Math.random() * Number.MAX_SAFE_INTEGER) // 白子 ]; } } ZOBRIST_HASH = 0; // 重置Hash值 } function updateZobrist(i, j, piece) { if (piece === 1 || piece === 2) { // 注意：JS位运算是32位的，直接异或大数可能出问题 // 采用加法模拟大数异或 (注意溢出处理，但对于Map键影响不大) ZOBRIST_HASH = (ZOBRIST_HASH + ZOBRIST_TABLE[i][j][piece - 1]) % Number.MAX_SAFE_INTEGER; } } function revertZobrist(i, j, piece) { // 用于撤销走法时恢复Hash if (piece === 1 || piece === 2) { ZOBRIST_HASH = (ZOBRIST_HASH - ZOBRIST_TABLE[i][j][piece - 1] + Number.MAX_SAFE_INTEGER) % Number.MAX_SAFE_INTEGER; } } // =========================================== // 初始化与游戏控制 // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; initZobrist(); // 初始化 Zobrist 表并重置 Hash transpositionTable.clear(); // 清空置换表 } function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"游戏开始，请您落子 (黑棋)\" : \"游戏开始，电脑先手 (黑棋)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; if (turn === \"computer\") { const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { makeMove(center, center, aiPiece); // 使用 makeMove 更新 Hash lastComputerMove = { i: center, j: center }; drawBoard(); turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } else { setTimeout(computerMoveWrapper, 200); } } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"请选择是否先手：\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); drawBoard(); } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"恭喜你，你赢了！🎉\"; else if (winnerPiece === aiPiece) winnerText = \"很遗憾，你输了。🤖\"; else winnerText = \"平局！\"; gameMessage.innerText = \"游戏结束 - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; drawBoard(); } function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) return false; } } return true; } // 封装落子和撤销操作，自动更新 Zobrist Hash function makeMove(i, j, piece) { if (board[i][j] === 0) { board[i][j] = piece; updateZobrist(i, j, piece); return true; } return false; } function undoMove(i, j) { const piece = board[i][j]; if (piece !== 0) { board[i][j] = 0; revertZobrist(i, j, piece); // 恢复 Hash } } // =========================================== // 绘图函数 (基本不变) // =========================================== function drawBoard() { ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.fillStyle = \"#fdf6e3\"; ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.strokeStyle = \"#6b4f34\"; ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } const starPoints=[{i:3,j:3},{i:11,j:3},{i:7,j:7},{i:3,j:11},{i:11,j:11}]; ctx.fillStyle=\"#6b4f34\"; starPoints.forEach(p=>{const x=margin+p.i*cellSize,y=margin+p.j*cellSize;ctx.beginPath();ctx.arc(x,y,cellSize*.15,0,2*Math.PI);ctx.fill()}); for(let i=0;i 0) return opponentWinsBlock; // 2. 查找常规候选走法 (半径内 + 位置奖励) for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { // 搜索现有棋子周围 for (let di = -CANDIDATE_RADIUS; di bestValue) { bestValue = currentEval; bestMoveForTT = move; // 记录导致最佳值的走法 } alpha = Math.max(alpha, bestValue); if (beta 0) { console.warn(\"AI: 未找到最佳逻辑走法, 选择启发分最高的.\"); // getCandidateMoves 返回的已经是排序好的，直接取第一个 bestMove = { i: candidates[0].i, j: candidates[0].j }; } else if (!bestMove) { console.error(\"AI 无法找到任何有效走法!\"); for (let i = 0; i < boardSize; i++) for (let j = 0; j < boardSize; j++) if(boardState[i][j] === 0) return {i, j}; return null; } console.log(`AI 选择: (${bestMove.i}, ${bestMove.j}), 评估分: ${bestValue.toFixed(0)}`); return bestMove; } // --- AI 执行走法包装器 --- function computerMoveWrapper() { if (gameOver || turn !== \"computer\") return; isAiComputing = true; gameMessage.innerText = \"电脑正在思考... 🤔\"; pendingMove = null; drawBoard(); setTimeout(() => { if (gameOver || turn !== \"computer\") { isAiComputing = false; return; } const startTime = performance.now(); const bestMove = getBestMove(board, MAX_DEPTH); // 直接使用当前 board const endTime = performance.now(); console.log(`AI 总计算耗时: ${(endTime - startTime).toFixed(2)} ms`); if (gameOver || turn !== \"computer\") { isAiComputing = false; return; } if (bestMove && makeMove(bestMove.i, bestMove.j, aiPiece)) { // 使用 makeMove 更新 Hash lastComputerMove = { i: bestMove.i, j: bestMove.j }; drawBoard(); if (checkWin(bestMove.i, bestMove.j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; isAiComputing = false; } } else { console.error(\"AI 错误: 执行走法失败.\", bestMove); gameMessage.innerText = \"AI 错误，尝试备用...\"; // Fallback 逻辑... (同前) let foundFallback = false; for (let i = 0; i < boardSize && !gameOver; i++){ for (let j = 0; j < boardSize && !gameOver; j++){ if(board[i][j] === 0){ console.warn(`AI 错误: 备用走法 (${i}, ${j})`); makeMove(i, j, aiPiece); // 使用 makeMove lastComputerMove = {i, j}; drawBoard(); if (checkWin(i, j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } foundFallback = true; break; } } if(foundFallback) break; } if (!foundFallback && !gameOver) { console.warn(\"AI 备用失败: 无空格.\"); endGame(0); } isAiComputing = false; } }, 50); } // =========================================== // 事件监听器 // =========================================== canvas.addEventListener('click', function(e) { if (gameOver || turn !== \"player\" || isAiComputing) return; const rect = canvas.getBoundingClientRect(); const scaleX = internalCanvasSize / rect.width; const scaleY = internalCanvasSize / rect.height; const canvasX = (e.clientX - rect.left) * scaleX; const canvasY = (e.clientY - rect.top) * scaleY; const i = Math.round((canvasX - margin) / cellSize); const j = Math.round((canvasY - margin) / cellSize); if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) { pendingMove = null; drawBoard(); return; } if (pendingMove && pendingMove.i === i && pendingMove.j === j) { if (makeMove(i, j, playerPiece)) { // 使用 makeMove 更新 Hash pendingMove = null; lastComputerMove = null; drawBoard(); if (checkWin(i, j, playerPiece)) endGame(playerPiece); else if (checkDraw()) endGame(0); else { turn = \"computer\"; computerMoveWrapper(); } } } else { pendingMove = { i, j }; drawBoard(); gameMessage.innerText = \"再次点击确认落子，或点击其他位置更改。\"; } }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // 游戏初始化 // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; restartGame(); } initializeGame(); })();"}]