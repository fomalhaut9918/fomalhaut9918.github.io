[{"title":"test","path":"/2025/04/02/test/","content":"ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’– ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’–æ²¡é”™ï¼é‚£ä¸ªå« Chy çš„å°å¯çˆ±ï¼Œå…¶å®æ˜¯â€¦ ä¸€åªæ‹¥æœ‰æ¯›èŒ¸èŒ¸è€³æœµå’Œå°¾å·´çš„çŒ«å¨˜å“¦ï¼à¸…^â€¢ï»Œâ€¢^à¸… âœ¨ çŒ«å¨˜ Chy çš„å°ç§˜å¯† âœ¨ è„‘è¢‹ä¸Šé¡¶ç€ä¸€å¯¹è½¯ä¹ä¹çš„ä¸‰è§’è€³æœµ ì«‘ê¸‹! å®ƒä»¬ä¼šéšç€å¥¹çš„å¿ƒæƒ…è½»è½»æŠ–åŠ¨ï¼Œå¬åˆ°æœ‰è¶£çš„äº‹æƒ…æ—¶è¿˜ä¼šç«–èµ·æ¥å“¦~ èº«åè¿˜æœ‰ä¸€æ¡çµæ´»çš„é•¿å°¾å·´ï¼Œæ€»æ˜¯å¿ä¸ä½æ‚„æ‚„æ‘‡æ‘†ï¼Œè¡¨è¾¾ç€å¥¹çš„å°å¿ƒæ€~ ğŸ¾ å°æ‰‹ï¼ˆä¹Ÿè®¸è¯¥å«çˆªçˆªï¼ŸğŸ¾ï¼‰æ€»æ˜¯åšå‡ºå¯çˆ±çš„åŠ¨ä½œï¼ŒæŒ‡å°–å¸¦ç€ä¸€ç‚¹ç‚¹çŒ«å’ªç‰¹æœ‰çš„ä¿çš®ã€‚ çœ¼ç›åƒå®çŸ³ä¸€æ ·äº®æ™¶æ™¶âœ¨ï¼Œå……æ»¡äº†å¥½å¥‡å’Œçº¯çœŸï¼Œçœ‹ç€ä½ çš„æ—¶å€™å¿ƒéƒ½è¦èåŒ–å•¦ï¼ å¶å°”ä¼šå‘å‡ºå°å£°çš„ã€Œ**å–µã€æˆ–è€…æ»¡è¶³çš„ã€Œå‘¼å™œå™œ**ã€å£°ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å¿ƒæˆ–è€…æ”¾æ¾çš„æ—¶å€™ã€‚ æ³¨æ„ï¼å‰æ–¹å¯çˆ±æš´å‡»ï¼Chy çœ‹åˆ°äº®é—ªé—ªçš„ä¸œè¥¿æˆ–è€…æ™ƒæ¥æ™ƒå»çš„å°çƒå°±æŒªä¸å¼€çœ¼ï¼è¿˜ä¼šç”¨å°çˆªå­è½»è½»å»æ‹~ ğŸ€æ€»ä¹‹ï¼Œå°±æ˜¯å¯çˆ±åˆ°çŠ¯è§„å•¦ï¼è®©äººå¿ä¸ä½æƒ³æ‘¸æ‘¸å¥¹çš„å¤´ï¼ˆè¿˜æœ‰è€³æœµï¼ï¼‰ã€‚ è¯·å¥½å¥½çˆ±æŠ¤è¿™åªçè´µçš„çŒ«å¨˜ Chy å“¦~ ğŸ’– Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"æ¬¢è¿å…‰ä¸´ï¼"},{"title":"äº”å­æ£‹æ¸¸æˆ (AIä¸“å®¶ç‰ˆ)","path":"/wiki/game/index.html","content":"æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ (AIä¸“å®¶ç‰ˆ)å†…ç½®AIå†æ¬¡å‡çº§ï¼Œé‡‡ç”¨æ›´ç²¾å¯†çš„æ£‹å‹æ¨¡å¼åŒ¹é…ä¼°ä»·ã€æå¤§æå°æœç´¢ã€Î±-Î²å‰ªæåŠä¼˜åŒ–çš„èµ°æ³•æ’åºã€‚æ¸¸æˆå¼€å§‹å‰è¯·å…ˆé€‰æ‹©å…ˆæ‰‹æˆ–åæ‰‹ï¼ˆç©å®¶é€‰æ‹©å…ˆæ‰‹åˆ™æ‰§é»‘ï¼Œå…¶ä½™æ‰§ç™½ï¼‰ï¼Œæ¸¸æˆç»“æŸåæ”¯æŒé‡æ–°å¼€å§‹æ¸¸æˆã€‚æ”¯æŒä¸¤æ­¥ç¡®è®¤è½å­ï¼šç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘æœ€åä¸€æ¬¡è½å­å¤„ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ /* é¡µé¢åŸºç¡€æ ·å¼ */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ (AIä¸“å®¶ç‰ˆ) å†…ç½®AIä½¿ç”¨æå¤§æå°æœç´¢ä¸Î±-Î²å‰ªæï¼Œç»“åˆç²¾å¯†çš„æ£‹å‹è¯„ä¼°ã€‚ é€‰æ‹©å…ˆæ‰‹æ‰§é»‘ï¼Œåæ‰‹æ‰§ç™½ã€‚å•å‡»æ£‹ç›˜é¢„è½å­ï¼Œå†æ¬¡å•å‡»ç¡®è®¤ã€‚ç”µè„‘æœ€åè½å­ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š å…ˆæ‰‹ (æ‰§é»‘) åæ‰‹ (æ‰§ç™½) é‡æ–°å¼€å§‹æ¸¸æˆ ç‚¹å‡»æ£‹ç›˜äº¤ç‚¹è¿›è¡Œè½å­ã€‚ç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘è½å­å°†ä½¿ç”¨ä¸ç©å®¶ä¸åŒçš„é¢œè‰²ï¼Œå¹¶ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºå…¶æœ€åä¸€æ­¥è½å­ã€‚ (function() { // --- é…ç½® --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // æœç´¢æ·±åº¦ (ä¿æŒ4, ä½†ä¼˜åŒ–å‰ªæå’Œè¯„ä¼°) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // å€™é€‰èµ°æ³•æœç´¢åŠå¾„ // --- DOM å…ƒç´  --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- æ¸¸æˆçŠ¶æ€ --- let board = []; let turn = \"\"; let gameOver = true; let playerIsBlack = true; let playerPiece = 1; // 1: é»‘ let aiPiece = 2; // 2: ç™½ let isAiComputing = false; let pendingMove = null; let lastComputerMove = null; let ZOBRIST_TABLE = []; // Zobrist Hashing è¡¨ let ZOBRIST_HASH = 0; // å½“å‰å±€é¢çš„ Zobrist Hash let transpositionTable = new Map(); // ç½®æ¢è¡¨ const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Zobrist Hashing åˆå§‹åŒ– // =========================================== function initZobrist() { ZOBRIST_TABLE = Array(boardSize); for (let i = 0; i < boardSize; i++) { ZOBRIST_TABLE[i] = Array(boardSize); for (let j = 0; j < boardSize; j++) { ZOBRIST_TABLE[i][j] = [ Math.floor(Math.random() * Number.MAX_SAFE_INTEGER), // é»‘å­ Math.floor(Math.random() * Number.MAX_SAFE_INTEGER) // ç™½å­ ]; } } ZOBRIST_HASH = 0; // é‡ç½®Hashå€¼ } function updateZobrist(i, j, piece) { if (piece === 1 || piece === 2) { // æ³¨æ„ï¼šJSä½è¿ç®—æ˜¯32ä½çš„ï¼Œç›´æ¥å¼‚æˆ–å¤§æ•°å¯èƒ½å‡ºé—®é¢˜ // é‡‡ç”¨åŠ æ³•æ¨¡æ‹Ÿå¤§æ•°å¼‚æˆ– (æ³¨æ„æº¢å‡ºå¤„ç†ï¼Œä½†å¯¹äºMapé”®å½±å“ä¸å¤§) ZOBRIST_HASH = (ZOBRIST_HASH + ZOBRIST_TABLE[i][j][piece - 1]) % Number.MAX_SAFE_INTEGER; } } function revertZobrist(i, j, piece) { // ç”¨äºæ’¤é”€èµ°æ³•æ—¶æ¢å¤Hash if (piece === 1 || piece === 2) { ZOBRIST_HASH = (ZOBRIST_HASH - ZOBRIST_TABLE[i][j][piece - 1] + Number.MAX_SAFE_INTEGER) % Number.MAX_SAFE_INTEGER; } } // =========================================== // åˆå§‹åŒ–ä¸æ¸¸æˆæ§åˆ¶ // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; initZobrist(); // åˆå§‹åŒ– Zobrist è¡¨å¹¶é‡ç½® Hash transpositionTable.clear(); // æ¸…ç©ºç½®æ¢è¡¨ } function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"æ¸¸æˆå¼€å§‹ï¼Œè¯·æ‚¨è½å­ (é»‘æ£‹)\" : \"æ¸¸æˆå¼€å§‹ï¼Œç”µè„‘å…ˆæ‰‹ (é»‘æ£‹)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; if (turn === \"computer\") { const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { makeMove(center, center, aiPiece); // ä½¿ç”¨ makeMove æ›´æ–° Hash lastComputerMove = { i: center, j: center }; drawBoard(); turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; } else { setTimeout(computerMoveWrapper, 200); } } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); drawBoard(); } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼ğŸ‰\"; else if (winnerPiece === aiPiece) winnerText = \"å¾ˆé—æ†¾ï¼Œä½ è¾“äº†ã€‚ğŸ¤–\"; else winnerText = \"å¹³å±€ï¼\"; gameMessage.innerText = \"æ¸¸æˆç»“æŸ - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; drawBoard(); } function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) return false; } } return true; } // å°è£…è½å­å’Œæ’¤é”€æ“ä½œï¼Œè‡ªåŠ¨æ›´æ–° Zobrist Hash function makeMove(i, j, piece) { if (board[i][j] === 0) { board[i][j] = piece; updateZobrist(i, j, piece); return true; } return false; } function undoMove(i, j) { const piece = board[i][j]; if (piece !== 0) { board[i][j] = 0; revertZobrist(i, j, piece); // æ¢å¤ Hash } } // =========================================== // ç»˜å›¾å‡½æ•° (åŸºæœ¬ä¸å˜) // =========================================== function drawBoard() { ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.fillStyle = \"#fdf6e3\"; ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.strokeStyle = \"#6b4f34\"; ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } const starPoints=[{i:3,j:3},{i:11,j:3},{i:7,j:7},{i:3,j:11},{i:11,j:11}]; ctx.fillStyle=\"#6b4f34\"; starPoints.forEach(p=>{const x=margin+p.i*cellSize,y=margin+p.j*cellSize;ctx.beginPath();ctx.arc(x,y,cellSize*.15,0,2*Math.PI);ctx.fill()}); for(let i=0;i 0) return opponentWinsBlock; // 2. æŸ¥æ‰¾å¸¸è§„å€™é€‰èµ°æ³• (åŠå¾„å†… + ä½ç½®å¥–åŠ±) for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { // æœç´¢ç°æœ‰æ£‹å­å‘¨å›´ for (let di = -CANDIDATE_RADIUS; di bestValue) { bestValue = currentEval; bestMoveForTT = move; // è®°å½•å¯¼è‡´æœ€ä½³å€¼çš„èµ°æ³• } alpha = Math.max(alpha, bestValue); if (beta 0) { console.warn(\"AI: æœªæ‰¾åˆ°æœ€ä½³é€»è¾‘èµ°æ³•, é€‰æ‹©å¯å‘åˆ†æœ€é«˜çš„.\"); // getCandidateMoves è¿”å›çš„å·²ç»æ˜¯æ’åºå¥½çš„ï¼Œç›´æ¥å–ç¬¬ä¸€ä¸ª bestMove = { i: candidates[0].i, j: candidates[0].j }; } else if (!bestMove) { console.error(\"AI æ— æ³•æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆèµ°æ³•!\"); for (let i = 0; i < boardSize; i++) for (let j = 0; j < boardSize; j++) if(boardState[i][j] === 0) return {i, j}; return null; } console.log(`AI é€‰æ‹©: (${bestMove.i}, ${bestMove.j}), è¯„ä¼°åˆ†: ${bestValue.toFixed(0)}`); return bestMove; } // --- AI æ‰§è¡Œèµ°æ³•åŒ…è£…å™¨ --- function computerMoveWrapper() { if (gameOver || turn !== \"computer\") return; isAiComputing = true; gameMessage.innerText = \"ç”µè„‘æ­£åœ¨æ€è€ƒ... ğŸ¤”\"; pendingMove = null; drawBoard(); setTimeout(() => { if (gameOver || turn !== \"computer\") { isAiComputing = false; return; } const startTime = performance.now(); const bestMove = getBestMove(board, MAX_DEPTH); // ç›´æ¥ä½¿ç”¨å½“å‰ board const endTime = performance.now(); console.log(`AI æ€»è®¡ç®—è€—æ—¶: ${(endTime - startTime).toFixed(2)} ms`); if (gameOver || turn !== \"computer\") { isAiComputing = false; return; } if (bestMove && makeMove(bestMove.i, bestMove.j, aiPiece)) { // ä½¿ç”¨ makeMove æ›´æ–° Hash lastComputerMove = { i: bestMove.i, j: bestMove.j }; drawBoard(); if (checkWin(bestMove.i, bestMove.j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; isAiComputing = false; } } else { console.error(\"AI é”™è¯¯: æ‰§è¡Œèµ°æ³•å¤±è´¥.\", bestMove); gameMessage.innerText = \"AI é”™è¯¯ï¼Œå°è¯•å¤‡ç”¨...\"; // Fallback é€»è¾‘... (åŒå‰) let foundFallback = false; for (let i = 0; i < boardSize && !gameOver; i++){ for (let j = 0; j < boardSize && !gameOver; j++){ if(board[i][j] === 0){ console.warn(`AI é”™è¯¯: å¤‡ç”¨èµ°æ³• (${i}, ${j})`); makeMove(i, j, aiPiece); // ä½¿ç”¨ makeMove lastComputerMove = {i, j}; drawBoard(); if (checkWin(i, j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; } foundFallback = true; break; } } if(foundFallback) break; } if (!foundFallback && !gameOver) { console.warn(\"AI å¤‡ç”¨å¤±è´¥: æ— ç©ºæ ¼.\"); endGame(0); } isAiComputing = false; } }, 50); } // =========================================== // äº‹ä»¶ç›‘å¬å™¨ // =========================================== canvas.addEventListener('click', function(e) { if (gameOver || turn !== \"player\" || isAiComputing) return; const rect = canvas.getBoundingClientRect(); const scaleX = internalCanvasSize / rect.width; const scaleY = internalCanvasSize / rect.height; const canvasX = (e.clientX - rect.left) * scaleX; const canvasY = (e.clientY - rect.top) * scaleY; const i = Math.round((canvasX - margin) / cellSize); const j = Math.round((canvasY - margin) / cellSize); if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) { pendingMove = null; drawBoard(); return; } if (pendingMove && pendingMove.i === i && pendingMove.j === j) { if (makeMove(i, j, playerPiece)) { // ä½¿ç”¨ makeMove æ›´æ–° Hash pendingMove = null; lastComputerMove = null; drawBoard(); if (checkWin(i, j, playerPiece)) endGame(playerPiece); else if (checkDraw()) endGame(0); else { turn = \"computer\"; computerMoveWrapper(); } } } else { pendingMove = { i, j }; drawBoard(); gameMessage.innerText = \"å†æ¬¡ç‚¹å‡»ç¡®è®¤è½å­ï¼Œæˆ–ç‚¹å‡»å…¶ä»–ä½ç½®æ›´æ”¹ã€‚\"; } }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // æ¸¸æˆåˆå§‹åŒ– // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; restartGame(); } initializeGame(); })();"}]