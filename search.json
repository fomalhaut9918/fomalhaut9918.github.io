[{"title":"test","path":"/2025/04/02/test/","content":"ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’– ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’–æ²¡é”™ï¼é‚£ä¸ªå« Chy çš„å°å¯çˆ±ï¼Œå…¶å®æ˜¯â€¦ ä¸€åªæ‹¥æœ‰æ¯›èŒ¸èŒ¸è€³æœµå’Œå°¾å·´çš„çŒ«å¨˜å“¦ï¼à¸…^â€¢ï»Œâ€¢^à¸… âœ¨ çŒ«å¨˜ Chy çš„å°ç§˜å¯† âœ¨ è„‘è¢‹ä¸Šé¡¶ç€ä¸€å¯¹è½¯ä¹ä¹çš„ä¸‰è§’è€³æœµ ì«‘ê¸‹! å®ƒä»¬ä¼šéšç€å¥¹çš„å¿ƒæƒ…è½»è½»æŠ–åŠ¨ï¼Œå¬åˆ°æœ‰è¶£çš„äº‹æƒ…æ—¶è¿˜ä¼šç«–èµ·æ¥å“¦~ èº«åè¿˜æœ‰ä¸€æ¡çµæ´»çš„é•¿å°¾å·´ï¼Œæ€»æ˜¯å¿ä¸ä½æ‚„æ‚„æ‘‡æ‘†ï¼Œè¡¨è¾¾ç€å¥¹çš„å°å¿ƒæ€~ ğŸ¾ å°æ‰‹ï¼ˆä¹Ÿè®¸è¯¥å«çˆªçˆªï¼ŸğŸ¾ï¼‰æ€»æ˜¯åšå‡ºå¯çˆ±çš„åŠ¨ä½œï¼ŒæŒ‡å°–å¸¦ç€ä¸€ç‚¹ç‚¹çŒ«å’ªç‰¹æœ‰çš„ä¿çš®ã€‚ çœ¼ç›åƒå®çŸ³ä¸€æ ·äº®æ™¶æ™¶âœ¨ï¼Œå……æ»¡äº†å¥½å¥‡å’Œçº¯çœŸï¼Œçœ‹ç€ä½ çš„æ—¶å€™å¿ƒéƒ½è¦èåŒ–å•¦ï¼ å¶å°”ä¼šå‘å‡ºå°å£°çš„ã€Œ**å–µã€æˆ–è€…æ»¡è¶³çš„ã€Œå‘¼å™œå™œ**ã€å£°ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å¿ƒæˆ–è€…æ”¾æ¾çš„æ—¶å€™ã€‚ æ³¨æ„ï¼å‰æ–¹å¯çˆ±æš´å‡»ï¼Chy çœ‹åˆ°äº®é—ªé—ªçš„ä¸œè¥¿æˆ–è€…æ™ƒæ¥æ™ƒå»çš„å°çƒå°±æŒªä¸å¼€çœ¼ï¼è¿˜ä¼šç”¨å°çˆªå­è½»è½»å»æ‹~ ğŸ€æ€»ä¹‹ï¼Œå°±æ˜¯å¯çˆ±åˆ°çŠ¯è§„å•¦ï¼è®©äººå¿ä¸ä½æƒ³æ‘¸æ‘¸å¥¹çš„å¤´ï¼ˆè¿˜æœ‰è€³æœµï¼ï¼‰ã€‚ è¯·å¥½å¥½çˆ±æŠ¤è¿™åªçè´µçš„çŒ«å¨˜ Chy å“¦~ ğŸ’– Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"æ¬¢è¿å…‰ä¸´ï¼"},{"title":"äº”å­æ£‹æ¸¸æˆ (AIå¢å¼ºç‰ˆ)","path":"/wiki/game/index.html","content":"æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ (AIå¢å¼ºç‰ˆ)å†…ç½®AIç»è¿‡ä¼˜åŒ–ï¼Œä½¿ç”¨åŸºäºæ£‹å‹çš„ä¼°ä»·å‡½æ•°ã€æå¤§æå°æœç´¢ä¸Î±-Î²å‰ªæåŠèµ°æ³•æ’åºã€‚æ¸¸æˆå¼€å§‹å‰è¯·å…ˆé€‰æ‹©å…ˆæ‰‹æˆ–åæ‰‹ï¼ˆç©å®¶é€‰æ‹©å…ˆæ‰‹åˆ™æ‰§é»‘ï¼Œå…¶ä½™æ‰§ç™½ï¼‰ï¼Œæ¸¸æˆç»“æŸåæ”¯æŒé‡æ–°å¼€å§‹æ¸¸æˆã€‚å¦å¤–ï¼Œæ¸¸æˆæ”¯æŒä¸¤æ­¥ç¡®è®¤è½å­ï¼šç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘æœ€åä¸€æ¬¡è½å­å¤„ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºï¼Œå¸®åŠ©ç›´è§‚æŸ¥çœ‹ç”µè„‘å†³ç­–ã€‚ /* é¡µé¢åŸºç¡€æ ·å¼ */ body { background: #f8f8f8; color: #333; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; text-align: center; line-height: 1.6; } #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } #secondBtn { background-color: #8e44ad; } #restartBtn { background-color: #27ae60; } /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; margin: 30px auto; overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); background: #fdf6e3; aspect-ratio: 1 / 1; } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; border: none; background: #fdf6e3; border-radius: 12px; } #gameMessage { font-size: 20px; font-weight: 500; margin-top: 0; margin-bottom: 15px; color: #555; min-height: 24px; } .info-text { font-size: 14px; color: #666; margin-top: 10px; margin-bottom: 20px; padding: 0 15px; } h1 { margin-top: 20px; margin-bottom: 10px; color: #333; } æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆ (AIå¢å¼ºç‰ˆ) å†…ç½®AIä½¿ç”¨æå¤§æå°æœç´¢ä¸Î±-Î²å‰ªæã€‚é€‰æ‹©å…ˆæ‰‹æ‰§é»‘ï¼Œåæ‰‹æ‰§ç™½ã€‚ å•å‡»æ£‹ç›˜é¢„è½å­ï¼Œå†æ¬¡å•å‡»ç¡®è®¤ã€‚ç”µè„‘æœ€åè½å­ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š å…ˆæ‰‹ (æ‰§é»‘) åæ‰‹ (æ‰§ç™½) é‡æ–°å¼€å§‹æ¸¸æˆ ç‚¹å‡»æ£‹ç›˜äº¤ç‚¹è¿›è¡Œè½å­ã€‚ç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘è½å­å°†ä½¿ç”¨ä¸ç©å®¶ä¸åŒçš„é¢œè‰²ï¼Œå¹¶ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºå…¶æœ€åä¸€æ­¥è½å­ã€‚ (function() { // --- é…ç½® --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // æœç´¢æ·±åº¦ (æ³¨æ„: æ·±åº¦4å¯èƒ½è¾ƒæ…¢, 3æ›´å®‰å…¨) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // å€™é€‰èµ°æ³•æœç´¢åŠå¾„ (1æˆ–2) // --- DOM å…ƒç´  --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- æ¸¸æˆçŠ¶æ€ --- let board = []; // 0: ç©º, 1: é»‘, 2: ç™½ let turn = \"\"; // \"player\", \"computer\", \"\" let gameOver = true; let playerIsBlack = true; let playerPiece = 1; let aiPiece = 2; let isAiComputing = false; let pendingMove = null; // å¾…ç¡®è®¤èµ°æ³• {i, j} let lastComputerMove = null;// AIæœ€åè½å­ {i, j} const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // åˆå§‹åŒ–ä¸æ¸¸æˆæ§åˆ¶ // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; } function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"æ¸¸æˆå¼€å§‹ï¼Œè¯·æ‚¨è½å­ (é»‘æ£‹)\" : \"æ¸¸æˆå¼€å§‹ï¼Œç”µè„‘å…ˆæ‰‹ (é»‘æ£‹)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; if (turn === \"computer\") { // AIå…ˆæ‰‹é»˜è®¤ä¸‹ä¸­é—´ const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { board[center][center] = aiPiece; lastComputerMove = { i: center, j: center }; drawBoard(); turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; } else { setTimeout(computerMoveWrapper, 200); // å¦‚æœä¸­é—´è¢«å åˆ™æ­£å¸¸è®¡ç®— } } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); drawBoard(); } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"æ­å–œä½ ï¼Œä½ èµ¢äº†ï¼ğŸ‰\"; else if (winnerPiece === aiPiece) winnerText = \"å¾ˆé—æ†¾ï¼Œä½ è¾“äº†ã€‚ğŸ¤–\"; else winnerText = \"å¹³å±€ï¼\"; gameMessage.innerText = \"æ¸¸æˆç»“æŸ - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; drawBoard(); } function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) return false; } } return true; } // =========================================== // ç»˜å›¾å‡½æ•° (åŸºæœ¬ä¸å˜) // =========================================== function drawBoard() { ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.fillStyle = \"#fdf6e3\"; ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.strokeStyle = \"#6b4f34\"; ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } const starPoints = [ { i: 3, j: 3 }, { i: 11, j: 3 }, { i: 7, j: 7 }, { i: 3, j: 11 }, { i: 11, j: 11 } ]; ctx.fillStyle = \"#6b4f34\"; starPoints.forEach(p => { const x = margin + p.i * cellSize; const y = margin + p.j * cellSize; ctx.beginPath(); ctx.arc(x, y, cellSize * 0.15, 0, 2 * Math.PI); ctx.fill(); }); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) drawStone(i, j, board[i][j]); } } if (pendingMove !== null && !gameOver) drawGhostStone(pendingMove.i, pendingMove.j, playerPiece); if (lastComputerMove !== null) highlightComputerMove(lastComputerMove.i, lastComputerMove.j); } function drawStone(i, j, type) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 2; if (type === 1) { ctx.fillStyle = \"#2c3e50\"; ctx.fill(); } else { ctx.fillStyle = \"#ecf0f1\"; ctx.fill(); ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1; ctx.stroke(); } ctx.restore(); } function drawGhostStone(i, j, type) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); if (type === 1) { ctx.fillStyle = \"#2c3e50\"; } else { ctx.fillStyle = \"#ecf0f1\"; } ctx.fill(); ctx.restore(); } function highlightComputerMove(i, j) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.strokeStyle = \"red\"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(x, y, radius + 3, 0, 2 * Math.PI); ctx.stroke(); ctx.restore(); } // =========================================== // èƒœè´Ÿåˆ¤æ–­ (ä¸å˜) // =========================================== function checkWin(x, y, piece) { const directions = [ { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 } ]; for (const { dx, dy } of directions) { let count = 1; for (let k = 1; k < WIN_CONDITION; k++) { const ni = x + k * dx, nj = y + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) count++; else break; } for (let k = 1; k < WIN_CONDITION; k++) { const ni = x - k * dx, nj = y - k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) count++; else break; } if (count >= WIN_CONDITION) return true; } return false; } // =========================================== // AI é€»è¾‘ (Minimax + Alpha-Beta + ä¼°ä»·ä¼˜åŒ–) // =========================================== function cloneBoard(src) { return src.map(row => row.slice()); } // --- ä¼˜åŒ–åçš„æ£‹å‹è¯„åˆ† --- const SCORES = { FIVE: 10000000, // è¿äº” LIVE_FOUR: 1000000, // æ´»å›› DEAD_FOUR: 50000, // å†²å›› / æ­»å›› LIVE_THREE: 50000, // æ´»ä¸‰ (é‡è¦æ€§ç­‰åŒæ­»å››) DEAD_THREE: 1000, // æ­»ä¸‰ LIVE_TWO: 1000, // æ´»äºŒ (é‡è¦æ€§ç­‰åŒæ­»ä¸‰) DEAD_TWO: 100, // æ­»äºŒ LIVE_ONE: 10, // æ´»ä¸€ DEAD_ONE: 1, // æ­»ä¸€ OPP_FIVE: -50000000, // å¯¹æ‰‹è¿äº” (å¿…é¡»é˜²å®ˆ) OPP_LIVE_FOUR: -5000000, // å¯¹æ‰‹æ´»å›› (å¿…é¡»é˜²å®ˆ) OPP_DEAD_FOUR: -100000, // å¯¹æ‰‹å†²å››/æ­»å›› OPP_LIVE_THREE: -100000,// å¯¹æ‰‹æ´»ä¸‰ (å¨èƒå¤§) OPP_DEAD_THREE: -2000, // å¯¹æ‰‹æ­»ä¸‰ OPP_LIVE_TWO: -2000, // å¯¹æ‰‹æ´»äºŒ OPP_DEAD_TWO: -200, // å¯¹æ‰‹æ­»äºŒ OPP_LIVE_ONE: -20, // å¯¹æ‰‹æ´»ä¸€ OPP_DEAD_ONE: -2, // å¯¹æ‰‹æ­»ä¸€ }; // æ”¹è¿›çš„ä¼°ä»·å‡½æ•° function evaluateBoardState(boardState) { let totalScore = 0; const directions = [ {dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1} ]; // H, V, D/, D\\ const evaluatedLines = new Set(); // å­˜å‚¨å·²è¯„ä¼°çº¿çš„æ ‡è¯†ï¼Œé¿å…é‡å¤è®¡ç®— for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) continue; // åªä»æœ‰æ£‹å­çš„ç‚¹å¼€å§‹è¯„ä¼°çº¿ for (const { dx, dy } of directions) { const lineKey = `${i},${j},${dx},${dy}`; // æ£€æŸ¥æ­£å‘å’Œåå‘æ˜¯å¦å·²è®¡ç®—è¿‡ const reverseKey = `${i + (WIN_CONDITION - 1) * dx},${j + (WIN_CONDITION - 1) * dy},${-dx},${-dy}`; if (evaluatedLines.has(lineKey) || evaluatedLines.has(reverseKey)) { continue; } totalScore += scoreLine(boardState, i, j, dx, dy, aiPiece, playerPiece); evaluatedLines.add(lineKey); // æ ‡è®°æ­¤çº¿å·²è¯„ä¼° } } } return totalScore; } // è¯„ä¼°å•æ¡çº¿ (5ä¸ªä½ç½®) function scoreLine(boardState, r, c, dr, dc, myPiece, oppPiece) { let myCount = 0; let oppCount = 0; let linePieces = []; // å­˜å‚¨è¿™æ¡çº¿ä¸Šçš„æ£‹å­ (0, 1, or 2) // è·å–è¿™æ¡çº¿ä¸Šçš„5ä¸ªæ£‹å­ for (let k = 0; k < WIN_CONDITION; k++) { const nr = r + k * dr; const nc = c + k * dc; if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) { return 0; // çº¿å‡ºç•Œï¼Œæ— æ³•æˆäº” } const piece = boardState[nr][nc]; linePieces.push(piece); if (piece === myPiece) myCount++; else if (piece === oppPiece) oppCount++; } // å¦‚æœçº¿ä¸ŠåŒæ—¶æœ‰åŒæ–¹æ£‹å­ï¼Œåˆ™æ­¤çº¿æ— æ³•æˆäº”ï¼Œåˆ†æ•°ä¸º0 if (myCount > 0 && oppCount > 0) { return 0; } // è·å–çº¿ä¸¤ç«¯çš„æ£‹å­çŠ¶æ€ (ç”¨äºåˆ¤æ–­æ´»/æ­») const prev_r = r - dr; const prev_c = c - dc; const prevPiece = (prev_r >= 0 && prev_r < boardSize && prev_c >= 0 && prev_c < boardSize) ? boardState[prev_r][prev_c] : -1; // -1è¡¨ç¤ºè¾¹ç•Œå¤– const next_r = r + WIN_CONDITION * dr; const next_c = c + WIN_CONDITION * dc; const nextPiece = (next_r >= 0 && next_r < boardSize && next_c >= 0 && next_c < boardSize) ? boardState[next_r][next_c] : -1; // -1è¡¨ç¤ºè¾¹ç•Œå¤– // æ ¹æ®æˆ‘æ–¹æˆ–å¯¹æ–¹æ£‹å­æ•°é‡è¯„åˆ† if (myCount > 0) { return getPatternScore(myCount, prevPiece === 0, nextPiece === 0, false); } else if (oppCount > 0) { return getPatternScore(oppCount, prevPiece === 0, nextPiece === 0, true); } return 0; // å…¨ç©ºçº¿ } // æ ¹æ®æ£‹å­æ•°é‡å’Œä¸¤ç«¯å¼€æ”¾æƒ…å†µè·å–åˆ†æ•° function getPatternScore(count, isOpenPrev, isOpenNext, isOpponent) { const scoreMap = isOpponent ? { // å¯¹æ‰‹æ£‹å‹ FIVE: SCORES.OPP_FIVE, LIVE_FOUR: SCORES.OPP_LIVE_FOUR, DEAD_FOUR: SCORES.OPP_DEAD_FOUR, LIVE_THREE: SCORES.OPP_LIVE_THREE, DEAD_THREE: SCORES.OPP_DEAD_THREE, LIVE_TWO: SCORES.OPP_LIVE_TWO, DEAD_TWO: SCORES.OPP_DEAD_TWO, LIVE_ONE: SCORES.OPP_LIVE_ONE, DEAD_ONE: SCORES.OPP_DEAD_ONE } : { // æˆ‘æ–¹æ£‹å‹ FIVE: SCORES.FIVE, LIVE_FOUR: SCORES.LIVE_FOUR, DEAD_FOUR: SCORES.DEAD_FOUR, LIVE_THREE: SCORES.LIVE_THREE, DEAD_THREE: SCORES.DEAD_THREE, LIVE_TWO: SCORES.LIVE_TWO, DEAD_TWO: SCORES.DEAD_TWO, LIVE_ONE: SCORES.LIVE_ONE, DEAD_ONE: SCORES.DEAD_ONE }; if (count === 5) return scoreMap.FIVE; if (count === 4) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_FOUR; // ä¸¤ç«¯çš†ç©º -> æ´»å›› if (isOpenPrev || isOpenNext) return scoreMap.DEAD_FOUR; // ä¸€ç«¯ç©º -> å†²å››/æ­»å›› // (ä¸¤ç«¯è¢«å µæ­»çš„æƒ…å†µåœ¨æ­¤5æ ¼æ¨¡å‹ä¸‹ä¸ä¼šå‡ºç°count=4) } if (count === 3) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_THREE; // ä¸¤ç«¯çš†ç©º -> æ´»ä¸‰ if (isOpenPrev || isOpenNext) return scoreMap.DEAD_THREE; // ä¸€ç«¯ç©º -> æ­»ä¸‰ } if (count === 2) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_TWO; // ä¸¤ç«¯çš†ç©º -> æ´»äºŒ if (isOpenPrev || isOpenNext) return scoreMap.DEAD_TWO; // ä¸€ç«¯ç©º -> æ­»äºŒ } if (count === 1) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_ONE; // ä¸¤ç«¯çš†ç©º -> æ´»ä¸€ if (isOpenPrev || isOpenNext) return scoreMap.DEAD_ONE; // ä¸€ç«¯ç©º -> æ­»ä¸€ } return 0; // å…¶ä»–æƒ…å†µ (å¦‚ä¸¤ç«¯è¢«å µæ­»çš„ä¸‰/äºŒ/ä¸€) ä»·å€¼è¾ƒä½ï¼Œæš‚ä¸ç»™åˆ† } // --- ç”Ÿæˆå€™é€‰èµ°æ³• --- function getCandidateMoves(boardState) { let candidates = new Map(); // ä½¿ç”¨Mapé¿å…é‡å¤: {\"i,j\": {i, j, bonus}} let hasStones = false; const center = Math.floor(boardSize / 2); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // åœ¨ç°æœ‰æ£‹å­å‘¨å›´åŠå¾„å†…æœç´¢ç©ºä½ for (let di = -CANDIDATE_RADIUS; di èµ°æ³• (${move.i}, ${move.j}) è¯„ä¼°åˆ†: ${moveValue.toFixed(0)} (å¯å‘åˆ†: ${move.heuristicScore.toFixed(0)})`); if (moveValue > bestValue) { bestValue = moveValue; bestMove = { i: move.i, j: move.j }; } alpha = Math.max(alpha, moveValue); // æ›´æ–°alphaå€¼ // æ ¹èŠ‚ç‚¹çš„å¾ªç¯ä¸éœ€è¦betaå‰ªæ, å› ä¸ºæˆ‘ä»¬è¦æ‰¾åˆ°å…¨å±€æœ€ä¼˜è§£ } // Fallback å¤„ç† if (!bestMove && candidates.length > 0) { console.warn(\"AI: æœªæ‰¾åˆ°æœ€ä½³é€»è¾‘èµ°æ³•, é€‰æ‹©å¯å‘åˆ†æœ€é«˜çš„.\"); bestMove = { i: candidates[0].i, j: candidates[0].j }; } else if (!bestMove) { console.error(\"AI æ— æ³•æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆèµ°æ³•! (æ£‹ç›˜å·²æ»¡æˆ–é”™è¯¯)\"); // æœ€åçš„å°è¯•: æ‰¾ç¬¬ä¸€ä¸ªç©ºæ ¼ for (let i = 0; i < boardSize; i++) for (let j = 0; j < boardSize; j++) if(boardState[i][j] === 0) return {i, j}; return null; } console.log(`AI é€‰æ‹©: (${bestMove.i}, ${bestMove.j}), è¯„ä¼°åˆ†: ${bestValue.toFixed(0)}`); return bestMove; } // --- AI æ‰§è¡Œèµ°æ³•åŒ…è£…å™¨ --- function computerMoveWrapper() { if (gameOver || turn !== \"computer\") return; isAiComputing = true; gameMessage.innerText = \"ç”µè„‘æ­£åœ¨æ€è€ƒ... ğŸ¤”\"; pendingMove = null; drawBoard(); // æ¸…é™¤å¾…å®šå¹¶åˆ·æ–°UI setTimeout(() => { // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ï¼Œé˜²æ­¢AIè®¡ç®—æœŸé—´æ¸¸æˆç»“æŸ if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI è®¡ç®—ä¸­æ­¢ï¼Œæ¸¸æˆçŠ¶æ€å·²æ”¹å˜ã€‚\"); return; } const startTime = performance.now(); // è®°å½•å¼€å§‹æ—¶é—´ const bestMove = getBestMove(cloneBoard(board), MAX_DEPTH); // è·å–æœ€ä½³èµ°æ³• (ä¼ é€’å‰¯æœ¬) const endTime = performance.now(); // è®°å½•ç»“æŸæ—¶é—´ console.log(`AI è®¡ç®—è€—æ—¶: ${(endTime - startTime).toFixed(2)} ms`); // å†æ¬¡æ£€æŸ¥æ¸¸æˆçŠ¶æ€ if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI è®¡ç®—åä¸­æ­¢ï¼Œæ¸¸æˆçŠ¶æ€å·²æ”¹å˜ã€‚\"); return; } // æ‰§è¡Œèµ°æ³• if (bestMove && board[bestMove.i][bestMove.j] === 0) { board[bestMove.i][bestMove.j] = aiPiece; lastComputerMove = { i: bestMove.i, j: bestMove.j }; drawBoard(); if (checkWin(bestMove.i, bestMove.j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; isAiComputing = false; } } else { console.error(\"AI é”™è¯¯: é€‰æ‹©æ— æ•ˆèµ°æ³•ã€æ— èµ°æ³•æˆ–ä½ç½®å·²è¢«å ç”¨.\", bestMove); gameMessage.innerText = \"AI é”™è¯¯ï¼Œå°è¯•å¤‡ç”¨...\"; // Fallback: æ‰¾ç¬¬ä¸€ä¸ªç©ºæ ¼ let foundFallback = false; for (let i = 0; i < boardSize && !gameOver; i++){ for (let j = 0; j < boardSize && !gameOver; j++){ if(board[i][j] === 0){ console.warn(`AI é”™è¯¯: å¤‡ç”¨èµ°æ³• (${i}, ${j})`); board[i][j] = aiPiece; lastComputerMove = {i, j}; drawBoard(); if (checkWin(i, j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"è½®åˆ°ä½ äº†ï¼Œè¯·è½å­ã€‚\"; } foundFallback = true; break; } } if(foundFallback) break; } if (!foundFallback && !gameOver) { console.warn(\"AI å¤‡ç”¨å¤±è´¥: æ— ç©ºæ ¼.\"); endGame(0); } isAiComputing = false; } }, 50); // çŸ­æš‚å»¶è¿Ÿä»¥å…è®¸UIæ›´æ–° } // =========================================== // äº‹ä»¶ç›‘å¬å™¨ (é€»è¾‘ä¸å˜) // =========================================== canvas.addEventListener('click', function(e) { if (gameOver || turn !== \"player\" || isAiComputing) return; const rect = canvas.getBoundingClientRect(); const scaleX = internalCanvasSize / rect.width; const scaleY = internalCanvasSize / rect.height; const canvasX = (e.clientX - rect.left) * scaleX; const canvasY = (e.clientY - rect.top) * scaleY; const i = Math.round((canvasX - margin) / cellSize); const j = Math.round((canvasY - margin) / cellSize); if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) { pendingMove = null; drawBoard(); return; } if (pendingMove && pendingMove.i === i && pendingMove.j === j) { // ç¡®è®¤è½å­ board[i][j] = playerPiece; pendingMove = null; lastComputerMove = null; drawBoard(); if (checkWin(i, j, playerPiece)) endGame(playerPiece); else if (checkDraw()) endGame(0); else { turn = \"computer\"; computerMoveWrapper(); } // è½®åˆ°AI } else { // é¢„è½å­ pendingMove = { i, j }; drawBoard(); gameMessage.innerText = \"å†æ¬¡ç‚¹å‡»ç¡®è®¤è½å­ï¼Œæˆ–ç‚¹å‡»å…¶ä»–ä½ç½®æ›´æ”¹ã€‚\"; } }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // æ¸¸æˆåˆå§‹åŒ– // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; restartGame(); // è¿›å…¥é€‰æ‹©ç•Œé¢ } initializeGame(); })();"}]