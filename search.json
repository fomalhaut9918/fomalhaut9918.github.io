[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。另外，游戏支持两步确认落子：第一次点击显示预落子效果，第二次点击确认落子。电脑最后一次落子处以红色圆环标出，帮助直观查看电脑决策。 /* 页面基础样式 */ body { background: #f8f8f8; /* Slightly softer background */ color: #333; /* Standard text color */ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Modern font stack */ margin: 0; padding: 0; text-align: center; line-height: 1.6; } /* Prevent scrolling on the game area on touch devices */ #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } /* Dark Blue */ #secondBtn { background-color: #8e44ad; } /* Purple */ #restartBtn { background-color: #27ae60; } /* Green */ /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; /* Responsive width */ margin: 30px auto; /* Adjusted margin */ overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); /* Softer shadow */ background: #fdf6e3; /* Board background */ aspect-ratio: 1 / 1; /* Maintain square aspect ratio */ } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; /* Fill container */ border: none; background: #fdf6e3; /* Same as container, or transparent */ border-radius: 12px; /* Match container */ } #gameMessage { font-size: 20px; /* Slightly smaller */ font-weight: 500; margin-top: 0; /* Removed default margin */ margin-bottom: 15px; /* Space before buttons */ color: #555; } /* Adding a class for the intro text below the H1 */ .info-text { font-size: 14px; color: #666; margin-top: 10px; /* Reduced top margin */ margin-bottom: 20px; /* Space before game container */ padding: 0 15px; /* Add padding on smaller screens */ } /* Style for H1 */ h1 { margin-top: 20px; /* Space above title */ margin-bottom: 10px; /* Space below title */ color: #333; } 欢迎来到五子棋游戏 内置AI使用极大极小搜索与α-β剪枝。选择先手执黑，后手执白。 单击棋盘预落子，再次单击确认。电脑最后落子以红色圆环标出。 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 (function() { // --- Configuration --- const boardSize = 15; // Standard 15x15 board const internalCanvasSize = 640; // High internal resolution const margin = 30; // Increased margin for better edge spacing const MAX_DEPTH = 3; // AI search depth (adjust for performance) const WIN_CONDITION = 5; // 5 in a row to win // --- DOM Elements --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const gameContainer = document.getElementById('gameContainer'); // Needed for aspect ratio // --- Game State --- let board = []; // 0: empty, 1: black, 2: white let turn = \"\"; // \"player\", \"computer\", or \"\" (before start) let gameOver = true; // Start in game over state until first/second chosen let playerIsBlack = true; // Player's color choice let playerPiece = 1; // Piece value for the player let aiPiece = 2; // Piece value for the AI let isAiComputing = false; // Flag to prevent clicks during AI turn let pendingMove = null; // {i, j} for two-step confirmation let lastComputerMove = null;// {i, j} to highlight AI's last move // Calculate cell size based on internal resolution and margin const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Initialization and Game Control Functions // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; } function setupGame(playerStarts) { playerIsBlack = playerStarts; if (playerIsBlack) { playerPiece = 1; // Black aiPiece = 2; // White turn = \"player\"; gameMessage.innerText = \"游戏开始，请您落子 (黑棋)\"; } else { playerPiece = 2; // White aiPiece = 1; // Black turn = \"computer\"; gameMessage.innerText = \"游戏开始，电脑先手 (黑棋)\"; } gameOver = false; isAiComputing = false; initBoard(); drawBoard(); // Disable selection buttons, show restart button firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; // If computer starts, initiate its move if (turn === \"computer\") { // Add a slight delay for the user to see the initial board setTimeout(computerMoveWrapper, 500); } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; // Reset computing flag gameMessage.innerText = \"请选择是否先手：\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); // Clear board data drawBoard(); // Redraw empty board } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; // Ensure AI stops if it was thinking let winnerText = \"\"; if (winnerPiece === playerPiece) { winnerText = \"恭喜你，你赢了！🎉\"; } else if (winnerPiece === aiPiece) { winnerText = \"很遗憾，你输了。🤖\"; } else { winnerText = \"平局！\"; // Should be rare in Gomoku } gameMessage.innerText = \"游戏结束 - \" + winnerText; restartBtn.style.display = \"inline-block\"; // Ensure restart is visible pendingMove = null; // Clear any pending move visually drawBoard(); // Redraw to remove pending move ghost } // Check if the board is full (draw condition) function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) { return false; // Found an empty spot } } } return true; // No empty spots left } // =========================================== // Drawing Functions (Unchanged from previous version) // =========================================== function drawBoard() { // Clear canvas ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); // Draw background ctx.fillStyle = \"#fdf6e3\"; // Light beige background ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); // Draw grid lines ctx.strokeStyle = \"#6b4f34\"; // Brownish lines ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; // Vertical line ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); // Horizontal line ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } // Draw standard star points (optional, for aesthetics) const starPoints = [ { i: 3, j: 3 }, { i: 11, j: 3 }, { i: 7, j: 7 }, { i: 3, j: 11 }, { i: 11, j: 11 } ]; ctx.fillStyle = \"#6b4f34\"; starPoints.forEach(p => { const x = margin + p.i * cellSize; const y = margin + p.j * cellSize; ctx.beginPath(); ctx.arc(x, y, cellSize * 0.15, 0, 2 * Math.PI); ctx.fill(); }); // Draw placed stones for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) { drawStone(i, j, board[i][j]); } } } // Draw pending move (ghost stone) if (pendingMove !== null && !gameOver) { drawGhostStone(pendingMove.i, pendingMove.j, playerPiece); } // Highlight AI's last move if (lastComputerMove !== null) { highlightComputerMove(lastComputerMove.i, lastComputerMove.j); } } function drawStone(i, j, type) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; // Slightly smaller radius for spacing ctx.save(); // Save context state ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); // Add subtle shadow ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 2; if (type === 1) { // Black stone ctx.fillStyle = \"#2c3e50\"; // Dark blue-grey ctx.fill(); } else { // White stone ctx.fillStyle = \"#ecf0f1\"; // Light grey ctx.fill(); // Add a thin border to white stones for contrast ctx.strokeStyle = \"#bdc3c7\"; // Medium grey border ctx.lineWidth = 1; ctx.stroke(); } ctx.restore(); // Restore context state (removes shadow for next drawings) } function drawGhostStone(i, j, type) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; ctx.save(); ctx.globalAlpha = 0.5; // Make it semi-transparent ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); if (type === 1) { ctx.fillStyle = \"#2c3e50\"; } else { ctx.fillStyle = \"#ecf0f1\"; } ctx.fill(); ctx.restore(); } function highlightComputerMove(i, j) { const x = margin + i * cellSize; const y = margin + j * cellSize; const radius = cellSize / 2 * 0.85; // Match stone radius ctx.save(); ctx.strokeStyle = \"red\"; ctx.lineWidth = 3; // Make highlight thicker ctx.beginPath(); // Draw arc slightly larger than the stone ctx.arc(x, y, radius + 3, 0, 2 * Math.PI); ctx.stroke(); ctx.restore(); } // =========================================== // Game Logic & Win Check (Unchanged checkWin) // =========================================== function checkWin(x, y, piece) { const directions = [ { dx: 1, dy: 0 }, // Horizontal { dx: 0, dy: 1 }, // Vertical { dx: 1, dy: 1 }, // Diagonal / { dx: 1, dy: -1 } // Diagonal \\ ]; for (const { dx, dy } of directions) { let count = 1; // Count the piece just placed // Check in the positive direction (dx, dy) for (let k = 1; k < WIN_CONDITION; k++) { const ni = x + k * dx; const nj = y + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) { count++; } else { break; // Stop if out of bounds or different piece } } // Check in the negative direction (-dx, -dy) for (let k = 1; k < WIN_CONDITION; k++) { const ni = x - k * dx; const nj = y - k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) { count++; } else { break; // Stop if out of bounds or different piece } } if (count >= WIN_CONDITION) { return true; // Found a winning line } } return false; // No winning line found for this move } // =========================================== // AI Logic (Minimax with Alpha-Beta) - IMPROVED // =========================================== function cloneBoard(src) { // Correct deep copy return src.map(row => row.slice()); } // --- NEW: Enhanced Evaluation Function --- // Based on pattern scoring inspired by the CSDN blog post function evaluateBoardState(boardState) { const scores = { // AI (Maximizer) scores - higher is better for AI FIVE: 10000000, // Five in a row LIVE_FOUR: 100000, // Unblocked four **** DEAD_FOUR: 1000, // One end blocked four *** LIVE_THREE: 5000, // Unblocked three ** DEAD_THREE: 50, // One end blocked three * LIVE_TWO: 10, // Unblocked two DEAD_TWO: 2, // One end blocked two LIVE_ONE: 1, // Unblocked one DEAD_ONE: 0, // Blocked one (or less) - typically score 0 // Player (Minimizer) scores - more negative is better for AI (worse for player) OPP_FIVE: -100000000, // Player five in a row (more urgent to block) OPP_LIVE_FOUR: -500000, // Player live four (very urgent) OPP_DEAD_FOUR: -2000, // Player dead four OPP_LIVE_THREE: -10000, // Player live three (urgent block) OPP_DEAD_THREE: -100, // Player dead three OPP_LIVE_TWO: -20, OPP_DEAD_TWO: -4, OPP_LIVE_ONE: -1, OPP_DEAD_ONE: 0 }; let totalScore = 0; const directions = [{dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1}]; // Use a Set to avoid recounting the same line segment in different directions/starts const visited = new Set(); // Store keys like \"i,j,dx,dy\" for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { // No need to evaluate from empty spots if (boardState[i][j] === 0) continue; for (const { dx, dy } of directions) { const key = `${i},${j},${dx},${dy}`; const reverseKey = `${i+4*dx},${j+4*dy},${-dx},${-dy}`; // Key for the end point in reverse dir // If this starting point and direction OR the reverse has been visited, skip if (visited.has(key) || visited.has(reverseKey)) continue; let line = []; // Stores the 5 pieces/empty spots in the line let validLine = true; for (let k = 0; k < 5; k++) { const ni = i + k * dx; const nj = j + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize) { line.push(boardState[ni][nj]); } else { validLine = false; // Line goes off board break; } } if (validLine) { const score = evaluateLine(line, scores); totalScore += score; // Mark this line segment as visited (only the start point and direction) visited.add(key); } } } } return totalScore; } // Helper function to evaluate a single line of 5 spots function evaluateLine(line, scoresConfig) { let aiCount = 0; let playerCount = 0; let emptyCount = 0; for (const piece of line) { if (piece === aiPiece) aiCount++; else if (piece === playerPiece) playerCount++; else emptyCount++; } // --- Rule 1: Mixed pieces - Line is useless --- if (aiCount > 0 && playerCount > 0) { return 0; } // --- Rule 2: AI patterns --- if (aiCount > 0) { switch (aiCount) { case 5: return scoresConfig.FIVE; case 4: // Check if the empty spot makes it live (0XXXX or XXXX0) if (line[0] === 0 || line[4] === 0) return scoresConfig.LIVE_FOUR; else return scoresConfig.DEAD_FOUR; // Should be rare if only 1 empty, maybe XX0XX? Evaluate as dead. case 3: // Check for live three (0XXX0) if (line[0] === 0 && line[4] === 0) return scoresConfig.LIVE_THREE; // Check for dead three (e.g., WXXX0, 0XXXW, X0XXX, XX0XX) - Needs more refined open end check // Simplified: If not live three, consider it dead three if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_THREE; // At least one end open else return scoresConfig.DEAD_THREE / 2; // Both ends blocked is less valuable than dead three case 2: // Check for live two (00XX0, 0XX00) - simplified if (line[0] === 0 && line[4] === 0 && (line[1] === 0 || line[3] === 0)) return scoresConfig.LIVE_TWO; if ((line[0] === 0 && line[3] === 0) || (line[1] === 0 && line[4] === 0)) return scoresConfig.LIVE_TWO; // 0XX0X or X0XX0 patterns // Simplified: If at least one end open if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_TWO; else return scoresConfig.DEAD_TWO / 2; case 1: if (line[0] === 0 && line[4] === 0) return scoresConfig.LIVE_ONE; // 0X000 or 00X00 etc. if(line[0] === 0 || line[4] === 0) return scoresConfig.DEAD_ONE; // Actually might be 0 for dead one else return 0; // Blocked one default: return 0; } } // --- Rule 3: Player patterns (negative scores) --- if (playerCount > 0) { switch (playerCount) { case 5: return scoresConfig.OPP_FIVE; case 4: if (line[0] === 0 || line[4] === 0) return scoresConfig.OPP_LIVE_FOUR; else return scoresConfig.OPP_DEAD_FOUR; case 3: if (line[0] === 0 && line[4] === 0) { // Special case from blog: 0WWW0 -> higher threat if(line[1] === playerPiece && line[2] === playerPiece && line[3] === playerPiece) return scoresConfig.OPP_LIVE_THREE * 2; // Boost score for central live three return scoresConfig.OPP_LIVE_THREE; } if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_THREE; else return scoresConfig.OPP_DEAD_THREE / 2; case 2: if (line[0] === 0 && line[4] === 0 && (line[1] === 0 || line[3] === 0)) return scoresConfig.OPP_LIVE_TWO; if ((line[0] === 0 && line[3] === 0) || (line[1] === 0 && line[4] === 0)) return scoresConfig.OPP_LIVE_TWO; if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_TWO; else return scoresConfig.OPP_DEAD_TWO / 2; case 1: if (line[0] === 0 && line[4] === 0) return scoresConfig.OPP_LIVE_ONE; if(line[0] === 0 || line[4] === 0) return scoresConfig.OPP_DEAD_ONE; else return 0; default: return 0; } } return 0; // Line contains only empty spots } // --- NEW: Generate candidate moves with positional bonus --- function getCandidateMoves(boardState, radius = 1) { // Reduced default radius to 1 for potentially faster pruning let candidates = new Map(); let hasStones = false; const center = Math.floor(boardSize / 2); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // Look around this stone for (let di = -radius; di"}]