[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。支持两步确认落子。电脑最后一次落子处以红色圆环标出。 /* 页面基础样式 */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} /* 加载指示器 */ .thinking-indicator{display:inline-block;margin-left:10px;width:24px;height:24px;vertical-align:middle;border:3px solid rgba(0,0,0,0.1);border-radius:50%;border-top-color:#3498db;animation:spin 1s linear infinite;display:none} @keyframes spin{to{transform:rotate(360deg)}} 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。 (function() { // --- 配置 --- const boardSize = 15; // 棋盘大小 15x15 const internalCanvasSize = 640; // 画布内部大小 const margin = 30; // 边距 const WIN_CONDITION = 5; // 获胜条件：连续5子 const MAX_SEARCH_DEPTH = 6; // 最大搜索深度，增加以提高棋力 const THREAT_SEARCH_DEPTH = 8; // 威胁空间搜索深度，增加以改进威胁搜索 const VCF_SEARCH_DEPTH = 10; // 连续冲四胜利搜索深度 // --- DOM 元素 --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); const thinkingIndicator = document.getElementById('thinkingIndicator'); // --- 游戏状态 --- let board = []; // 棋盘状态 let turn = \"\"; // 当前回合：player 或 computer let gameOver = true; // 游戏是否结束 let playerIsBlack = true; // 玩家是否执黑 let playerPiece = 1; // 玩家棋子：1=黑, 2=白 let aiPiece = 2; // AI棋子：2=白, 1=黑 let isAiComputing = false; // AI是否正在计算 let pendingMove = null; // 待确认的走法 let lastComputerMove = null; // 电脑最后一步走法 let transpositionTable = new Map(); // 置换表，用于存储已搜索过的局面 let historyTable = []; // 历史表，用于存储优秀的走法 // --- 计算棋盘单元格大小 --- const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // --- 增强型棋型评分系统 --- const PATTERN_SCORES = { // 必胜局面 FIVE: 10000000, // 连五，绝对胜利 // 必杀棋型 OPEN_FOUR: 1000000, // 活四，下一步必胜 DOUBLE_FOUR: 500000, // 双冲四，也是下一步必胜 FOUR_THREE: 400000, // 冲四活三组合，强力威胁 // 强威胁棋型 FOUR: 50000, // 冲四，需要防守 DOUBLE_OPEN_THREE: 100000, // 双活三，非常强力的棋型 // 中等威胁棋型 OPEN_THREE: 10000, // 活三 DOUBLE_THREE: 9000, // 双眠三 THREE_TWO: 8000, // 眠三活二组合 // 轻微威胁棋型 THREE: 1000, // 眠三 OPEN_TWO: 500, // 活二 DOUBLE_TWO: 400, // 双眠二 // 基础棋型 TWO: 100, // 眠二 OPEN_ONE: 50, // 活一 ONE: 10, // 眠一 // 权重系数 - 调整进攻和防守的平衡 ATTACK_FACTOR: 1.1, // 进攻系数略高，鼓励主动进攻 DEFENSE_FACTOR: 1.2 // 防守系数更高，确保不会忽视严重威胁 }; // --- 棋盘位置权重 --- // 越接近中心的位置，权重越高 const POSITION_VALUES = [ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0], [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 6, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 6, 6, 6, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0], [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0], [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0], [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] ]; // --- 开局库 --- // 包含一些经典的五子棋开局 const OPENING_BOOK = { // 天元开局 'center': [ {i: 7, j: 7} // 天元点 ], // 黑方天元开局后，白方的应对 '7-7': [ {i: 6, j: 6}, // 左上 {i: 6, j: 8}, // 左下 {i: 8, j: 6}, // 右上 {i: 8, j: 8} // 右下 ], // 花月开局 'huayue': [ {i: 7, j: 7}, // 天元 {i: 7, j: 6}, // 花月位 {i: 8, j: 6} // 应手 ], // 星开局 'star': [ {i: 7, j: 7}, // 天元 {i: 3, j: 3}, // 星位 {i: 11, j: 11} // 应手 ], // 更多高级开局策略 'advanced_responses': { // 应对黑方其他常见开局的策略 '7-6': [{i: 7, j: 8}, {i: 8, j: 7}, {i: 6, j: 7}], // 应对黑方花月 '3-3': [{i: 7, j: 7}, {i: 11, j: 11}], // 应对黑方星位 '3-11': [{i: 7, j: 7}, {i: 11, j: 3}] // 应对黑方星位变形 } }; // --- 初始化历史表 --- function initHistoryTable() { historyTable = []; for (let i = 0; i < boardSize; i++) { historyTable[i] = []; for (let j = 0; j < boardSize; j++) { historyTable[i][j] = 0; } } } // --- 初始化棋盘 --- function initBoard() { board = []; for (let i = 0; i < boardSize; i++) { board[i] = []; for (let j = 0; j < boardSize; j++) { board[i][j] = 0; } } lastComputerMove = null; pendingMove = null; transpositionTable.clear(); initHistoryTable(); } // --- 重新开始游戏 --- function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"请选择是否先手：\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; thinkingIndicator.style.display = \"none\"; initBoard(); drawBoard(); } // --- 设置游戏 --- function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"游戏开始，请您落子 (黑棋)\" : \"游戏开始，电脑先手 (黑棋)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; // 如果AI先手，走天元 if (turn === \"computer\") { const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { makeMove(center, center, aiPiece); lastComputerMove = {i: center, j: center}; drawBoard(); turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } else { setTimeout(computerMove, 200); } } } // --- 结束游戏 --- function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"恭喜你，你赢了！🎉\"; else if (winnerPiece === aiPiece) winnerText = \"很遗憾，你输了。🤖\"; else winnerText = \"平局！\"; gameMessage.innerText = \"游戏结束 - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; thinkingIndicator.style.display = \"none\"; drawBoard(); } // --- 计算当前棋盘状态的哈希值 (用于置换表) --- function hashBoard() { let hash = 0; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) { hash = hash * 3 + board[i][j]; } } } return hash; } // --- 高级棋型识别 --- // 分析棋型的核心函数 function analyzeLine(line, piece) { const opponent = piece === 1 ? 2 : 1; const pieceChar = piece.toString(); // 提取复杂棋型 // 连五 if (line.includes(pieceChar.repeat(5))) { return PATTERN_SCORES.FIVE; } // 活四: 0XXXX0 (一步就能连五) if (line.includes(`0${pieceChar.repeat(4)}0`)) { return PATTERN_SCORES.OPEN_FOUR; } // 检查多个冲四形式 let fourCount = 0; if (line.includes(`${pieceChar.repeat(4)}0`)) fourCount++; if (line.includes(`0${pieceChar.repeat(4)}`)) fourCount++; if (line.includes(`${pieceChar}0${pieceChar.repeat(3)}`)) fourCount++; if (line.includes(`${pieceChar.repeat(2)}0${pieceChar.repeat(2)}`)) fourCount++; if (line.includes(`${pieceChar.repeat(3)}0${pieceChar}`)) fourCount++; // 双冲四 if (fourCount >= 2) { return PATTERN_SCORES.DOUBLE_FOUR; } // 单冲四 if (fourCount === 1) { // 检查是否同时有活三 (冲四活三组合) if (line.includes(`0${pieceChar.repeat(3)}0`)) { return PATTERN_SCORES.FOUR_THREE; } return PATTERN_SCORES.FOUR; } // 检查活三 let openThreeCount = 0; const openThreePattern = `0${pieceChar.repeat(3)}0`; let pos = line.indexOf(openThreePattern); while (pos !== -1) { openThreeCount++; pos = line.indexOf(openThreePattern, pos + 1); } // 双活三 if (openThreeCount >= 2) { return PATTERN_SCORES.DOUBLE_OPEN_THREE; } // 单活三 if (openThreeCount === 1) { return PATTERN_SCORES.OPEN_THREE; } // 检查眠三 let threeCount = 0; if (line.includes(`${pieceChar.repeat(3)}0`)) threeCount++; if (line.includes(`0${pieceChar.repeat(3)}`)) threeCount++; if (line.includes(`${pieceChar}0${pieceChar.repeat(2)}`)) threeCount++; if (line.includes(`${pieceChar.repeat(2)}0${pieceChar}`)) threeCount++; // 双眠三 if (threeCount >= 2) { return PATTERN_SCORES.DOUBLE_THREE; } // 眠三 + 活二组合 if (threeCount === 1 && line.includes(`0${pieceChar.repeat(2)}0`)) { return PATTERN_SCORES.THREE_TWO; } // 单眠三 if (threeCount === 1) { return PATTERN_SCORES.THREE; } // 检查活二 let openTwoCount = 0; const openTwoPattern = `0${pieceChar.repeat(2)}0`; pos = line.indexOf(openTwoPattern); while (pos !== -1) { openTwoCount++; pos = line.indexOf(openTwoPattern, pos + 1); } // 双活二 if (openTwoCount >= 2) { return PATTERN_SCORES.DOUBLE_TWO; } // 单活二 if (openTwoCount === 1) { return PATTERN_SCORES.OPEN_TWO; } // 眠二 if (line.includes(`${pieceChar.repeat(2)}0`) || line.includes(`0${pieceChar.repeat(2)}`) || line.includes(`${pieceChar}0${pieceChar}`)) { return PATTERN_SCORES.TWO; } // 活一 if (line.includes(`0${pieceChar}0`)) { return PATTERN_SCORES.OPEN_ONE; } // 眠一 if (line.includes(`${pieceChar}0`) || line.includes(`0${pieceChar}`)) { return PATTERN_SCORES.ONE; } return 0; } // --- 提取线条上的棋型 --- function extractLine(row, col, dr, dc, radius) { let line = ''; for (let step = -radius; step = 0 && r < boardSize && c >= 0 && c < boardSize) { line += board[r][c]; } else { line += 'E'; // 边界外用E表示 } } return line.replace(/0/g, '0').replace(/1/g, '1').replace(/2/g, '2').replace(/E/g, 'E'); } // --- 新的五元组评估方法 --- // 评估棋盘上特定位置的五元组 function evaluateFiveGroup(row, col, piece) { // 四个方向: 水平、垂直、主对角线、副对角线 const directions = [ {dr: 1, dc: 0}, // 水平 {dr: 0, dc: 1}, // 垂直 {dr: 1, dc: 1}, // 主对角线 {dr: 1, dc: -1} // 副对角线 ]; let totalScore = 0; // 威胁统计 let threats = { FIVE: 0, OPEN_FOUR: 0, FOUR: 0, OPEN_THREE: 0, THREE: 0, OPEN_TWO: 0, TWO: 0 }; // 检查每个方向上的五元组 for (const {dr, dc} of directions) { // 获取当前方向上的线 const line = extractLine(row, col, dr, dc, 5); // 分析该线上的棋型 const score = analyzeLine(line, piece); totalScore += score; // 更新威胁统计 if (score >= PATTERN_SCORES.FIVE) threats.FIVE++; else if (score >= PATTERN_SCORES.OPEN_FOUR) threats.OPEN_FOUR++; else if (score >= PATTERN_SCORES.FOUR) threats.FOUR++; else if (score >= PATTERN_SCORES.OPEN_THREE) threats.OPEN_THREE++; else if (score >= PATTERN_SCORES.THREE) threats.THREE++; else if (score >= PATTERN_SCORES.OPEN_TWO) threats.OPEN_TWO++; else if (score >= PATTERN_SCORES.TWO) threats.TWO++; } // 检查复合威胁（多个方向的综合威胁） if (threats.OPEN_FOUR > 0 && threats.FOUR > 0) { totalScore += PATTERN_SCORES.DOUBLE_FOUR * 0.5; // 额外奖励，但避免重复计算 } if (threats.OPEN_THREE >= 2) { totalScore += PATTERN_SCORES.DOUBLE_OPEN_THREE * 0.5; // 额外奖励 } if (threats.THREE >= 2) { totalScore += PATTERN_SCORES.DOUBLE_THREE * 0.5; // 额外奖励 } return totalScore; } // --- 检查点周围是否有棋子 --- function hasNeighbor(row, col, radius) { for (let i = Math.max(0, row - radius); i"}]