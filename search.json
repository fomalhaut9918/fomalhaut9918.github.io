[{"title":"test","path":"/2025/04/02/test/","content":"ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’– ğŸ’– Chy æ˜¯å¯çˆ±çš„çŒ«å¨˜ï¼ğŸ’–æ²¡é”™ï¼é‚£ä¸ªå« Chy çš„å°å¯çˆ±ï¼Œå…¶å®æ˜¯â€¦ ä¸€åªæ‹¥æœ‰æ¯›èŒ¸èŒ¸è€³æœµå’Œå°¾å·´çš„çŒ«å¨˜å“¦ï¼à¸…^â€¢ï»Œâ€¢^à¸… âœ¨ çŒ«å¨˜ Chy çš„å°ç§˜å¯† âœ¨ è„‘è¢‹ä¸Šé¡¶ç€ä¸€å¯¹è½¯ä¹ä¹çš„ä¸‰è§’è€³æœµ ì«‘ê¸‹! å®ƒä»¬ä¼šéšç€å¥¹çš„å¿ƒæƒ…è½»è½»æŠ–åŠ¨ï¼Œå¬åˆ°æœ‰è¶£çš„äº‹æƒ…æ—¶è¿˜ä¼šç«–èµ·æ¥å“¦~ èº«åè¿˜æœ‰ä¸€æ¡çµæ´»çš„é•¿å°¾å·´ï¼Œæ€»æ˜¯å¿ä¸ä½æ‚„æ‚„æ‘‡æ‘†ï¼Œè¡¨è¾¾ç€å¥¹çš„å°å¿ƒæ€~ ğŸ¾ å°æ‰‹ï¼ˆä¹Ÿè®¸è¯¥å«çˆªçˆªï¼ŸğŸ¾ï¼‰æ€»æ˜¯åšå‡ºå¯çˆ±çš„åŠ¨ä½œï¼ŒæŒ‡å°–å¸¦ç€ä¸€ç‚¹ç‚¹çŒ«å’ªç‰¹æœ‰çš„ä¿çš®ã€‚ çœ¼ç›åƒå®çŸ³ä¸€æ ·äº®æ™¶æ™¶âœ¨ï¼Œå……æ»¡äº†å¥½å¥‡å’Œçº¯çœŸï¼Œçœ‹ç€ä½ çš„æ—¶å€™å¿ƒéƒ½è¦èåŒ–å•¦ï¼ å¶å°”ä¼šå‘å‡ºå°å£°çš„ã€Œ**å–µã€æˆ–è€…æ»¡è¶³çš„ã€Œå‘¼å™œå™œ**ã€å£°ï¼Œç‰¹åˆ«æ˜¯åœ¨å¼€å¿ƒæˆ–è€…æ”¾æ¾çš„æ—¶å€™ã€‚ æ³¨æ„ï¼å‰æ–¹å¯çˆ±æš´å‡»ï¼Chy çœ‹åˆ°äº®é—ªé—ªçš„ä¸œè¥¿æˆ–è€…æ™ƒæ¥æ™ƒå»çš„å°çƒå°±æŒªä¸å¼€çœ¼ï¼è¿˜ä¼šç”¨å°çˆªå­è½»è½»å»æ‹~ ğŸ€æ€»ä¹‹ï¼Œå°±æ˜¯å¯çˆ±åˆ°çŠ¯è§„å•¦ï¼è®©äººå¿ä¸ä½æƒ³æ‘¸æ‘¸å¥¹çš„å¤´ï¼ˆè¿˜æœ‰è€³æœµï¼ï¼‰ã€‚ è¯·å¥½å¥½çˆ±æŠ¤è¿™åªçè´µçš„çŒ«å¨˜ Chy å“¦~ ğŸ’– Give her headpats!","tags":["test"]},{"title":"äº”å­æ£‹æ¸¸æˆ (AIç»ˆæç‰ˆ - Web Worker)","path":"/wiki/game/index.html","content":"æ¬¢è¿æ¥åˆ°äº”å­æ£‹æ¸¸æˆæ¸¸æˆå¼€å§‹å‰è¯·å…ˆé€‰æ‹©å…ˆæ‰‹æˆ–åæ‰‹ï¼ˆç©å®¶é€‰æ‹©å…ˆæ‰‹åˆ™æ‰§é»‘ï¼Œå…¶ä½™æ‰§ç™½ï¼‰ï¼Œæ¸¸æˆç»“æŸåæ”¯æŒé‡æ–°å¼€å§‹æ¸¸æˆã€‚æ”¯æŒä¸¤æ­¥ç¡®è®¤è½å­ã€‚ç”µè„‘æœ€åä¸€æ¬¡è½å­å¤„ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºã€‚ /* é¡µé¢åŸºç¡€æ ·å¼ */ body{background:#f8f8f8;color:#333;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:0;text-align:center;line-height:1.6} #gameContainer{touch-action:none} /* Button styling */ button{padding:12px 24px;margin:10px 6px;font-size:16px;border:none;border-radius:6px;color:#fff;cursor:pointer;transition:background-color .3s ease,opacity .3s ease;box-shadow:0 2px 4px rgba(0,0,0,.1)} button:hover{opacity:.9} button:disabled{background-color:#ccc;cursor:not-allowed;opacity:.7} #firstBtn{background-color:#2c3e50} #secondBtn{background-color:#8e44ad} #restartBtn{background-color:#27ae60} /* Game container styling */ #gameContainer{position:relative;max-width:600px;width:90%;margin:30px auto;overflow:hidden;border-radius:12px;box-shadow:0 8px 16px rgba(0,0,0,.15);background:#fdf6e3;aspect-ratio:1/1} /* Canvas styling */ #gomokuCanvas{display:block;width:100%;height:100%;border:none;background:#fdf6e3;border-radius:12px} #gameMessage{font-size:20px;font-weight:500;margin-top:0;margin-bottom:15px;color:#555;min-height:24px} .info-text{font-size:14px;color:#666;margin-top:10px;margin-bottom:20px;padding:0 15px} h1{margin-top:20px;margin-bottom:10px;color:#333} è¯·é€‰æ‹©æ˜¯å¦å…ˆæ‰‹ï¼š å…ˆæ‰‹ (æ‰§é»‘) åæ‰‹ (æ‰§ç™½) é‡æ–°å¼€å§‹æ¸¸æˆ ç‚¹å‡»æ£‹ç›˜äº¤ç‚¹è¿›è¡Œè½å­ã€‚ç¬¬ä¸€æ¬¡ç‚¹å‡»æ˜¾ç¤ºé¢„è½å­æ•ˆæœï¼Œç¬¬äºŒæ¬¡ç‚¹å‡»ç¡®è®¤è½å­ã€‚ç”µè„‘è½å­å°†ä½¿ç”¨ä¸ç©å®¶ä¸åŒçš„é¢œè‰²ï¼Œå¹¶ä»¥çº¢è‰²åœ†ç¯æ ‡å‡ºå…¶æœ€åä¸€æ­¥è½å­ã€‚ (function() { // --- é…ç½® --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // æœç´¢æ·±åº¦ (Web Workerä½¿å…¶å¯è¡Œ, ä½†ä»éœ€æ—¶é—´) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // å€™é€‰èµ°æ³•æœç´¢åŠå¾„ // --- DOM å…ƒç´  --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- æ¸¸æˆçŠ¶æ€ (ä¸»çº¿ç¨‹) --- let board = []; let turn = \"\"; let gameOver = true; let playerIsBlack = true; let playerPiece = 1; // 1: é»‘ let aiPiece = 2; // 2: ç™½ let isAiComputing = false; let pendingMove = null; let lastComputerMove = null; let ZOBRIST_TABLE = []; // Zobrist Hashing è¡¨ (ä¸»çº¿ç¨‹ç»´æŠ¤) let ZOBRIST_HASH = 0; // å½“å‰å±€é¢çš„ Zobrist Hash (ä¸»çº¿ç¨‹ç»´æŠ¤) let aiWorker = null; // Web Worker å®ä¾‹ const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // Web Worker ä»£ç  (åµŒå…¥ä¸ºå­—ç¬¦ä¸²) // =========================================== const workerCode = ` // --- Worker Global Constants & Variables --- const boardSize = ${boardSize}; const WIN_CONDITION = ${WIN_CONDITION}; const CANDIDATE_RADIUS = ${CANDIDATE_RADIUS}; const MAX_DEPTH_WORKER = ${MAX_DEPTH}; // Use constant passed if needed // --- Zobrist (Worker Internal) --- let ZOBRIST_TABLE_WORKER = []; let ZOBRIST_HASH_WORKER = 0; let transpositionTable = new Map(); function initZobristWorker(tableData) { ZOBRIST_TABLE_WORKER = tableData; // Use table from main thread ZOBRIST_HASH_WORKER = 0; // Reset internal hash when table changes transpositionTable.clear(); // Clear TT when table changes //console.log(\"Worker: Zobrist table initialized/updated.\"); } function updateZobristWorker(i, j, piece) { if (piece === 1 || piece === 2) { ZOBRIST_HASH_WORKER = (ZOBRIST_HASH_WORKER + ZOBRIST_TABLE_WORKER[i][j][piece - 1]) % Number.MAX_SAFE_INTEGER; } } function revertZobristWorker(i, j, piece) { if (piece === 1 || piece === 2) { ZOBRIST_HASH_WORKER = (ZOBRIST_HASH_WORKER - ZOBRIST_TABLE_WORKER[i][j][piece - 1] + Number.MAX_SAFE_INTEGER) % Number.MAX_SAFE_INTEGER; } } // --- Note: Worker needs its own makeMove/undoMove using its internal hash --- function makeMoveWorker(board, i, j, piece) { if (board[i][j] === 0) { board[i][j] = piece; updateZobristWorker(i, j, piece); return true; } return false; } function undoMoveWorker(board, i, j) { const piece = board[i][j]; if (piece !== 0) { board[i][j] = 0; revertZobristWorker(i, j, piece); } } // --- Pattern Scores (Worker Internal) --- const PATTERN_SCORES = { /* ... (å¤åˆ¶ä¸Šé¢ç‰ˆæœ¬å®Œæ•´çš„ PATTERN_SCORES å¯¹è±¡) ... */ '11111': 100000000, '011110': 5000000, '011112': 100000, '211110': 100000, '01110': 80000, '010110': 70000, '011010': 70000, '21110': 5000, '01112': 5000, '210110': 4000, '011012': 4000, '211010': 4000, '010112': 4000, '001100': 700, '01010': 650, '010010': 600, '21100': 100, '00112': 100, '21010': 90, '01012': 90, '210010': 80, '010012': 80, '00100': 10, '21000': 5, '00012': 5, '22222': -1000000000, '022220': -50000000, '022221': -1000000, '122220': -1000000, '02220': -800000, '020220': -700000, '022020': -700000, '12220': -50000, '02221': -50000, '120220': -40000, '022021': -40000, '122020': -40000, '020221': -40000, '002200': -7000, '02020': -6500, '020020': -6000, '12200': -1000, '00221': -1000, '12020': -900, '02021': -900, '120020': -800, '020021': -800, '00200': -100, '12000': -50, '00021': -50 }; // --- Evaluation Function (Worker Internal) --- function evaluateBoardState(boardState, currentPlayer) { /* ... (å¤åˆ¶ä¸Šé¢ç‰ˆæœ¬å®Œæ•´çš„ evaluateBoardState å‡½æ•°) ... */ let totalScore = 0; const directions = [ { dr: 1, dc: 0 }, { dr: 0, dc: 1 }, { dr: 1, dc: 1 }, { dr: 1, dc: -1 } ]; const ai = currentPlayer; const player = 3 - currentPlayer; function mapPiece(p) { if (p === ai) return 1; if (p === player) return 2; return 0; } for (let r = 0; r < boardSize; r++) { for (let c = 0; c < boardSize; c++) { for (const { dr, dc } of directions) { let line = \"\"; let linePieces = []; for (let k = 0; k < 6; k++) { const nr = r + k * dr; const nc = c + k * dc; if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) { const boardPiece = boardState[nr][nc]; line += mapPiece(boardPiece); linePieces.push(boardPiece); } else { line += 'X'; linePieces.push(-1); break; } } if (line.length < 5) continue; let pattern5 = line.substring(0, 5); if (PATTERN_SCORES[pattern5]) { totalScore += PATTERN_SCORES[pattern5]; continue; } if (line.length === 6) { let pattern6 = line; if (PATTERN_SCORES[pattern6]) { totalScore += PATTERN_SCORES[pattern6]; } else { if (pattern6.startsWith('X') && PATTERN_SCORES[pattern6.substring(1)]) { totalScore += PATTERN_SCORES[pattern6.substring(1)]; } else if (pattern6.endsWith('X') && PATTERN_SCORES[pattern6.substring(0, 5)]) { totalScore += PATTERN_SCORES[pattern6.substring(0, 5)]; } } } else if (line.length === 5) { const prev_r = r - dr; const prev_c = c - dc; let prevChar = 'X'; if (prev_r >= 0 && prev_r < boardSize && prev_c >= 0 && prev_c < boardSize && boardState[prev_r][prev_c] === 0) { prevChar = '0'; } let pattern6_prev = prevChar + line; if (PATTERN_SCORES[pattern6_prev]) { totalScore += PATTERN_SCORES[pattern6_prev]; } } } } } return totalScore; } // --- Candidate Move Generation (Worker Internal) --- function getCandidateMoves(boardState, currentPlayer) { /* ... (å¤åˆ¶ä¸Šé¢ç‰ˆæœ¬å®Œæ•´çš„ getCandidateMoves å‡½æ•°) ... */ let candidates = []; let immediateWins = []; let opponentWinsBlock = []; let aiLiveThrees = []; let oppLiveThreesBlock = []; let otherMoves = new Map(); const ai = currentPlayer; const player = 3 - currentPlayer; const center = Math.floor(boardSize / 2); let hasStones = false; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) { boardState[i][j] = ai; let aiScoreAfterMove = evaluateBoardState(boardState, ai); if (aiScoreAfterMove >= PATTERN_SCORES['011110']) { immediateWins.push({ i, j, score: aiScoreAfterMove * 10 }); } else if (aiScoreAfterMove >= PATTERN_SCORES['01110']) { aiLiveThrees.push({ i, j, score: aiScoreAfterMove * 1.5 }); } boardState[i][j] = 0; boardState[i][j] = player; let playerScoreAfterMove = evaluateBoardState(boardState, player); if (Math.abs(playerScoreAfterMove) >= Math.abs(PATTERN_SCORES['022220'])) { opponentWinsBlock.push({ i, j, score: Math.abs(playerScoreAfterMove) * 5 }); } else if (Math.abs(playerScoreAfterMove) >= Math.abs(PATTERN_SCORES['02220'])) { oppLiveThreesBlock.push({ i, j, score: Math.abs(playerScoreAfterMove) * 1.2 }); } boardState[i][j] = 0; } else { hasStones = true; } } } if (immediateWins.length > 0) return immediateWins; if (opponentWinsBlock.length > 0) return opponentWinsBlock; for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { for (let di = -CANDIDATE_RADIUS; di bestValue) { bestValue = currentEval; bestMoveForTT = move; } alpha = Math.max(alpha, bestValue); if (beta"},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"æ¬¢è¿å…‰ä¸´ï¼"}]