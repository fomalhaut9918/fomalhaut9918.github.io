[{"title":"test","path":"/2025/04/02/test/","content":"💖 Chy 是可爱的猫娘！💖 💖 Chy 是可爱的猫娘！💖没错！那个叫 Chy 的小可爱，其实是… 一只拥有毛茸茸耳朵和尾巴的猫娘哦！ฅ^•ﻌ•^ฅ ✨ 猫娘 Chy 的小秘密 ✨ 脑袋上顶着一对软乎乎的三角耳朵 쫑긋! 它们会随着她的心情轻轻抖动，听到有趣的事情时还会竖起来哦~ 身后还有一条灵活的长尾巴，总是忍不住悄悄摇摆，表达着她的小心思~ 🐾 小手（也许该叫爪爪？🐾）总是做出可爱的动作，指尖带着一点点猫咪特有的俏皮。 眼睛像宝石一样亮晶晶✨，充满了好奇和纯真，看着你的时候心都要融化啦！ 偶尔会发出小声的「**喵」或者满足的「呼噜噜**」声，特别是在开心或者放松的时候。 注意！前方可爱暴击！Chy 看到亮闪闪的东西或者晃来晃去的小球就挪不开眼！还会用小爪子轻轻去拍~ 🎀总之，就是可爱到犯规啦！让人忍不住想摸摸她的头（还有耳朵！）。 请好好爱护这只珍贵的猫娘 Chy 哦~ 💖 Give her headpats!","tags":["test"]},{"title":"Welcome to my blog!","path":"/wiki/blog/index.html","content":"欢迎光临！"},{"title":"五子棋游戏 (AI增强版)","path":"/wiki/game/index.html","content":"欢迎来到五子棋游戏 (AI增强版)内置AI经过优化，使用基于棋型的估价函数、极大极小搜索与α-β剪枝及走法排序。游戏开始前请先选择先手或后手（玩家选择先手则执黑，其余执白），游戏结束后支持重新开始游戏。另外，游戏支持两步确认落子：第一次点击显示预落子效果，第二次点击确认落子。电脑最后一次落子处以红色圆环标出，帮助直观查看电脑决策。 /* 页面基础样式 */ body { background: #f8f8f8; color: #333; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; text-align: center; line-height: 1.6; } #gameContainer { touch-action: none; } /* Button styling */ button { padding: 12px 24px; margin: 10px 6px; font-size: 16px; border: none; border-radius: 6px; color: #fff; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } button:hover { opacity: 0.9; } button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.7; } #firstBtn { background-color: #2c3e50; } #secondBtn { background-color: #8e44ad; } #restartBtn { background-color: #27ae60; } /* Game container styling */ #gameContainer { position: relative; max-width: 600px; width: 90%; margin: 30px auto; overflow: hidden; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.15); background: #fdf6e3; aspect-ratio: 1 / 1; } /* Canvas styling */ #gomokuCanvas { display: block; width: 100%; height: 100%; border: none; background: #fdf6e3; border-radius: 12px; } #gameMessage { font-size: 20px; font-weight: 500; margin-top: 0; margin-bottom: 15px; color: #555; min-height: 24px; } .info-text { font-size: 14px; color: #666; margin-top: 10px; margin-bottom: 20px; padding: 0 15px; } h1 { margin-top: 20px; margin-bottom: 10px; color: #333; } 欢迎来到五子棋游戏 (AI增强版) 内置AI使用极大极小搜索与α-β剪枝。选择先手执黑，后手执白。 单击棋盘预落子，再次单击确认。电脑最后落子以红色圆环标出。 请选择是否先手： 先手 (执黑) 后手 (执白) 重新开始游戏 点击棋盘交点进行落子。第一次点击显示预落子效果，第二次点击确认落子。电脑落子将使用与玩家不同的颜色，并以红色圆环标出其最后一步落子。 (function() { // --- 配置 --- const boardSize = 15; const internalCanvasSize = 640; const margin = 30; const MAX_DEPTH = 4; // 搜索深度 (注意: 深度4可能较慢, 3更安全) const WIN_CONDITION = 5; const CANDIDATE_RADIUS = 2; // 候选走法搜索半径 (1或2) // --- DOM 元素 --- const canvas = document.getElementById('gomokuCanvas'); const ctx = canvas.getContext('2d'); const gameMessage = document.getElementById('gameMessage'); const firstBtn = document.getElementById('firstBtn'); const secondBtn = document.getElementById('secondBtn'); const restartBtn = document.getElementById('restartBtn'); // --- 游戏状态 --- let board = []; // 0: 空, 1: 黑, 2: 白 let turn = \"\"; // \"player\", \"computer\", \"\" let gameOver = true; let playerIsBlack = true; let playerPiece = 1; let aiPiece = 2; let isAiComputing = false; let pendingMove = null; // 待确认走法 {i, j} let lastComputerMove = null;// AI最后落子 {i, j} const cellSize = (internalCanvasSize - 2 * margin) / (boardSize - 1); // =========================================== // 初始化与游戏控制 // =========================================== function initBoard() { board = Array.from({ length: boardSize }, () => Array(boardSize).fill(0)); lastComputerMove = null; pendingMove = null; } function setupGame(playerStarts) { playerIsBlack = playerStarts; playerPiece = playerIsBlack ? 1 : 2; aiPiece = playerIsBlack ? 2 : 1; turn = playerIsBlack ? \"player\" : \"computer\"; gameMessage.innerText = playerIsBlack ? \"游戏开始，请您落子 (黑棋)\" : \"游戏开始，电脑先手 (黑棋)\"; gameOver = false; isAiComputing = false; initBoard(); drawBoard(); firstBtn.disabled = true; secondBtn.disabled = true; restartBtn.style.display = \"inline-block\"; if (turn === \"computer\") { // AI先手默认下中间 const center = Math.floor(boardSize / 2); if (board[center][center] === 0) { board[center][center] = aiPiece; lastComputerMove = { i: center, j: center }; drawBoard(); turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } else { setTimeout(computerMoveWrapper, 200); // 如果中间被占则正常计算 } } } function restartGame() { gameOver = true; turn = \"\"; isAiComputing = false; gameMessage.innerText = \"请选择是否先手：\"; firstBtn.disabled = false; secondBtn.disabled = false; restartBtn.style.display = \"none\"; initBoard(); drawBoard(); } function endGame(winnerPiece) { gameOver = true; isAiComputing = false; let winnerText = \"\"; if (winnerPiece === playerPiece) winnerText = \"恭喜你，你赢了！🎉\"; else if (winnerPiece === aiPiece) winnerText = \"很遗憾，你输了。🤖\"; else winnerText = \"平局！\"; gameMessage.innerText = \"游戏结束 - \" + winnerText; restartBtn.style.display = \"inline-block\"; pendingMove = null; drawBoard(); } function checkDraw() { for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] === 0) return false; } } return true; } // =========================================== // 绘图函数 (基本不变) // =========================================== function drawBoard() { ctx.clearRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.fillStyle = \"#fdf6e3\"; ctx.fillRect(0, 0, internalCanvasSize, internalCanvasSize); ctx.strokeStyle = \"#6b4f34\"; ctx.lineWidth = 1; for (let i = 0; i < boardSize; i++) { const pos = margin + i * cellSize; ctx.beginPath(); ctx.moveTo(pos, margin); ctx.lineTo(pos, internalCanvasSize - margin); ctx.stroke(); ctx.beginPath(); ctx.moveTo(margin, pos); ctx.lineTo(internalCanvasSize - margin, pos); ctx.stroke(); } const starPoints = [ { i: 3, j: 3 }, { i: 11, j: 3 }, { i: 7, j: 7 }, { i: 3, j: 11 }, { i: 11, j: 11 } ]; ctx.fillStyle = \"#6b4f34\"; starPoints.forEach(p => { const x = margin + p.i * cellSize; const y = margin + p.j * cellSize; ctx.beginPath(); ctx.arc(x, y, cellSize * 0.15, 0, 2 * Math.PI); ctx.fill(); }); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (board[i][j] !== 0) drawStone(i, j, board[i][j]); } } if (pendingMove !== null && !gameOver) drawGhostStone(pendingMove.i, pendingMove.j, playerPiece); if (lastComputerMove !== null) highlightComputerMove(lastComputerMove.i, lastComputerMove.j); } function drawStone(i, j, type) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); ctx.shadowColor = \"rgba(0, 0, 0, 0.4)\"; ctx.shadowBlur = 5; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 2; if (type === 1) { ctx.fillStyle = \"#2c3e50\"; ctx.fill(); } else { ctx.fillStyle = \"#ecf0f1\"; ctx.fill(); ctx.strokeStyle = \"#bdc3c7\"; ctx.lineWidth = 1; ctx.stroke(); } ctx.restore(); } function drawGhostStone(i, j, type) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.globalAlpha = 0.5; ctx.beginPath(); ctx.arc(x, y, radius, 0, 2 * Math.PI); ctx.closePath(); if (type === 1) { ctx.fillStyle = \"#2c3e50\"; } else { ctx.fillStyle = \"#ecf0f1\"; } ctx.fill(); ctx.restore(); } function highlightComputerMove(i, j) { const x = margin + i * cellSize, y = margin + j * cellSize, radius = cellSize / 2 * 0.85; ctx.save(); ctx.strokeStyle = \"red\"; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(x, y, radius + 3, 0, 2 * Math.PI); ctx.stroke(); ctx.restore(); } // =========================================== // 胜负判断 (不变) // =========================================== function checkWin(x, y, piece) { const directions = [ { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 } ]; for (const { dx, dy } of directions) { let count = 1; for (let k = 1; k < WIN_CONDITION; k++) { const ni = x + k * dx, nj = y + k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) count++; else break; } for (let k = 1; k < WIN_CONDITION; k++) { const ni = x - k * dx, nj = y - k * dy; if (ni >= 0 && ni < boardSize && nj >= 0 && nj < boardSize && board[ni][nj] === piece) count++; else break; } if (count >= WIN_CONDITION) return true; } return false; } // =========================================== // AI 逻辑 (Minimax + Alpha-Beta + 估价优化) // =========================================== function cloneBoard(src) { return src.map(row => row.slice()); } // --- 优化后的棋型评分 --- const SCORES = { FIVE: 10000000, // 连五 LIVE_FOUR: 1000000, // 活四 DEAD_FOUR: 50000, // 冲四 / 死四 LIVE_THREE: 50000, // 活三 (重要性等同死四) DEAD_THREE: 1000, // 死三 LIVE_TWO: 1000, // 活二 (重要性等同死三) DEAD_TWO: 100, // 死二 LIVE_ONE: 10, // 活一 DEAD_ONE: 1, // 死一 OPP_FIVE: -50000000, // 对手连五 (必须防守) OPP_LIVE_FOUR: -5000000, // 对手活四 (必须防守) OPP_DEAD_FOUR: -100000, // 对手冲四/死四 OPP_LIVE_THREE: -100000,// 对手活三 (威胁大) OPP_DEAD_THREE: -2000, // 对手死三 OPP_LIVE_TWO: -2000, // 对手活二 OPP_DEAD_TWO: -200, // 对手死二 OPP_LIVE_ONE: -20, // 对手活一 OPP_DEAD_ONE: -2, // 对手死一 }; // 改进的估价函数 function evaluateBoardState(boardState) { let totalScore = 0; const directions = [ {dx:1, dy:0}, {dx:0, dy:1}, {dx:1, dy:1}, {dx:1, dy:-1} ]; // H, V, D/, D\\ const evaluatedLines = new Set(); // 存储已评估线的标识，避免重复计算 for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] === 0) continue; // 只从有棋子的点开始评估线 for (const { dx, dy } of directions) { const lineKey = `${i},${j},${dx},${dy}`; // 检查正向和反向是否已计算过 const reverseKey = `${i + (WIN_CONDITION - 1) * dx},${j + (WIN_CONDITION - 1) * dy},${-dx},${-dy}`; if (evaluatedLines.has(lineKey) || evaluatedLines.has(reverseKey)) { continue; } totalScore += scoreLine(boardState, i, j, dx, dy, aiPiece, playerPiece); evaluatedLines.add(lineKey); // 标记此线已评估 } } } return totalScore; } // 评估单条线 (5个位置) function scoreLine(boardState, r, c, dr, dc, myPiece, oppPiece) { let myCount = 0; let oppCount = 0; let linePieces = []; // 存储这条线上的棋子 (0, 1, or 2) // 获取这条线上的5个棋子 for (let k = 0; k < WIN_CONDITION; k++) { const nr = r + k * dr; const nc = c + k * dc; if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) { return 0; // 线出界，无法成五 } const piece = boardState[nr][nc]; linePieces.push(piece); if (piece === myPiece) myCount++; else if (piece === oppPiece) oppCount++; } // 如果线上同时有双方棋子，则此线无法成五，分数为0 if (myCount > 0 && oppCount > 0) { return 0; } // 获取线两端的棋子状态 (用于判断活/死) const prev_r = r - dr; const prev_c = c - dc; const prevPiece = (prev_r >= 0 && prev_r < boardSize && prev_c >= 0 && prev_c < boardSize) ? boardState[prev_r][prev_c] : -1; // -1表示边界外 const next_r = r + WIN_CONDITION * dr; const next_c = c + WIN_CONDITION * dc; const nextPiece = (next_r >= 0 && next_r < boardSize && next_c >= 0 && next_c < boardSize) ? boardState[next_r][next_c] : -1; // -1表示边界外 // 根据我方或对方棋子数量评分 if (myCount > 0) { return getPatternScore(myCount, prevPiece === 0, nextPiece === 0, false); } else if (oppCount > 0) { return getPatternScore(oppCount, prevPiece === 0, nextPiece === 0, true); } return 0; // 全空线 } // 根据棋子数量和两端开放情况获取分数 function getPatternScore(count, isOpenPrev, isOpenNext, isOpponent) { const scoreMap = isOpponent ? { // 对手棋型 FIVE: SCORES.OPP_FIVE, LIVE_FOUR: SCORES.OPP_LIVE_FOUR, DEAD_FOUR: SCORES.OPP_DEAD_FOUR, LIVE_THREE: SCORES.OPP_LIVE_THREE, DEAD_THREE: SCORES.OPP_DEAD_THREE, LIVE_TWO: SCORES.OPP_LIVE_TWO, DEAD_TWO: SCORES.OPP_DEAD_TWO, LIVE_ONE: SCORES.OPP_LIVE_ONE, DEAD_ONE: SCORES.OPP_DEAD_ONE } : { // 我方棋型 FIVE: SCORES.FIVE, LIVE_FOUR: SCORES.LIVE_FOUR, DEAD_FOUR: SCORES.DEAD_FOUR, LIVE_THREE: SCORES.LIVE_THREE, DEAD_THREE: SCORES.DEAD_THREE, LIVE_TWO: SCORES.LIVE_TWO, DEAD_TWO: SCORES.DEAD_TWO, LIVE_ONE: SCORES.LIVE_ONE, DEAD_ONE: SCORES.DEAD_ONE }; if (count === 5) return scoreMap.FIVE; if (count === 4) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_FOUR; // 两端皆空 -> 活四 if (isOpenPrev || isOpenNext) return scoreMap.DEAD_FOUR; // 一端空 -> 冲四/死四 // (两端被堵死的情况在此5格模型下不会出现count=4) } if (count === 3) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_THREE; // 两端皆空 -> 活三 if (isOpenPrev || isOpenNext) return scoreMap.DEAD_THREE; // 一端空 -> 死三 } if (count === 2) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_TWO; // 两端皆空 -> 活二 if (isOpenPrev || isOpenNext) return scoreMap.DEAD_TWO; // 一端空 -> 死二 } if (count === 1) { if (isOpenPrev && isOpenNext) return scoreMap.LIVE_ONE; // 两端皆空 -> 活一 if (isOpenPrev || isOpenNext) return scoreMap.DEAD_ONE; // 一端空 -> 死一 } return 0; // 其他情况 (如两端被堵死的三/二/一) 价值较低，暂不给分 } // --- 生成候选走法 --- function getCandidateMoves(boardState) { let candidates = new Map(); // 使用Map避免重复: {\"i,j\": {i, j, bonus}} let hasStones = false; const center = Math.floor(boardSize / 2); for (let i = 0; i < boardSize; i++) { for (let j = 0; j < boardSize; j++) { if (boardState[i][j] !== 0) { hasStones = true; // 在现有棋子周围半径内搜索空位 for (let di = -CANDIDATE_RADIUS; di 走法 (${move.i}, ${move.j}) 评估分: ${moveValue.toFixed(0)} (启发分: ${move.heuristicScore.toFixed(0)})`); if (moveValue > bestValue) { bestValue = moveValue; bestMove = { i: move.i, j: move.j }; } alpha = Math.max(alpha, moveValue); // 更新alpha值 // 根节点的循环不需要beta剪枝, 因为我们要找到全局最优解 } // Fallback 处理 if (!bestMove && candidates.length > 0) { console.warn(\"AI: 未找到最佳逻辑走法, 选择启发分最高的.\"); bestMove = { i: candidates[0].i, j: candidates[0].j }; } else if (!bestMove) { console.error(\"AI 无法找到任何有效走法! (棋盘已满或错误)\"); // 最后的尝试: 找第一个空格 for (let i = 0; i < boardSize; i++) for (let j = 0; j < boardSize; j++) if(boardState[i][j] === 0) return {i, j}; return null; } console.log(`AI 选择: (${bestMove.i}, ${bestMove.j}), 评估分: ${bestValue.toFixed(0)}`); return bestMove; } // --- AI 执行走法包装器 --- function computerMoveWrapper() { if (gameOver || turn !== \"computer\") return; isAiComputing = true; gameMessage.innerText = \"电脑正在思考... 🤔\"; pendingMove = null; drawBoard(); // 清除待定并刷新UI setTimeout(() => { // 再次检查游戏状态，防止AI计算期间游戏结束 if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI 计算中止，游戏状态已改变。\"); return; } const startTime = performance.now(); // 记录开始时间 const bestMove = getBestMove(cloneBoard(board), MAX_DEPTH); // 获取最佳走法 (传递副本) const endTime = performance.now(); // 记录结束时间 console.log(`AI 计算耗时: ${(endTime - startTime).toFixed(2)} ms`); // 再次检查游戏状态 if (gameOver || turn !== \"computer\") { isAiComputing = false; console.log(\"AI 计算后中止，游戏状态已改变。\"); return; } // 执行走法 if (bestMove && board[bestMove.i][bestMove.j] === 0) { board[bestMove.i][bestMove.j] = aiPiece; lastComputerMove = { i: bestMove.i, j: bestMove.j }; drawBoard(); if (checkWin(bestMove.i, bestMove.j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; isAiComputing = false; } } else { console.error(\"AI 错误: 选择无效走法、无走法或位置已被占用.\", bestMove); gameMessage.innerText = \"AI 错误，尝试备用...\"; // Fallback: 找第一个空格 let foundFallback = false; for (let i = 0; i < boardSize && !gameOver; i++){ for (let j = 0; j < boardSize && !gameOver; j++){ if(board[i][j] === 0){ console.warn(`AI 错误: 备用走法 (${i}, ${j})`); board[i][j] = aiPiece; lastComputerMove = {i, j}; drawBoard(); if (checkWin(i, j, aiPiece)) endGame(aiPiece); else if (checkDraw()) endGame(0); else { turn = \"player\"; gameMessage.innerText = \"轮到你了，请落子。\"; } foundFallback = true; break; } } if(foundFallback) break; } if (!foundFallback && !gameOver) { console.warn(\"AI 备用失败: 无空格.\"); endGame(0); } isAiComputing = false; } }, 50); // 短暂延迟以允许UI更新 } // =========================================== // 事件监听器 (逻辑不变) // =========================================== canvas.addEventListener('click', function(e) { if (gameOver || turn !== \"player\" || isAiComputing) return; const rect = canvas.getBoundingClientRect(); const scaleX = internalCanvasSize / rect.width; const scaleY = internalCanvasSize / rect.height; const canvasX = (e.clientX - rect.left) * scaleX; const canvasY = (e.clientY - rect.top) * scaleY; const i = Math.round((canvasX - margin) / cellSize); const j = Math.round((canvasY - margin) / cellSize); if (i < 0 || i >= boardSize || j < 0 || j >= boardSize || board[i][j] !== 0) { pendingMove = null; drawBoard(); return; } if (pendingMove && pendingMove.i === i && pendingMove.j === j) { // 确认落子 board[i][j] = playerPiece; pendingMove = null; lastComputerMove = null; drawBoard(); if (checkWin(i, j, playerPiece)) endGame(playerPiece); else if (checkDraw()) endGame(0); else { turn = \"computer\"; computerMoveWrapper(); } // 轮到AI } else { // 预落子 pendingMove = { i, j }; drawBoard(); gameMessage.innerText = \"再次点击确认落子，或点击其他位置更改。\"; } }); firstBtn.addEventListener('click', () => setupGame(true)); secondBtn.addEventListener('click', () => setupGame(false)); restartBtn.addEventListener('click', restartGame); // =========================================== // 游戏初始化 // =========================================== function initializeGame() { canvas.width = internalCanvasSize; canvas.height = internalCanvasSize; restartGame(); // 进入选择界面 } initializeGame(); })();"}]